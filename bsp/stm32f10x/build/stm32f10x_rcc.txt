; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\build\stm32f10x_rcc.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -Iapplications -I. -Idrivers -ILibraries\STM32F10x_StdPeriph_Driver\inc -ILibraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\components\CMSIS\Include -I..\..\include -I..\..\libcpu\arm\cortex-m3 -I..\..\libcpu\arm\common -I..\..\components\drivers\include -I..\..\components\drivers\include -I..\..\components\drivers\include -I..\..\components\drivers\include -I..\..\components\drivers\spi -I..\..\components\drivers\include -I..\..\components\drivers\include -I..\..\components\finsh -I..\..\components\libc\compilers\armlibc -I..\..\components\libc\compilers\common -IE:\00_snake.xiao\RT-Thread\rt-thread\bsp\stm32f10x\RTE\_rtthread-stm32 -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DSTM32F10X_HD -DSTM32F10X_HD -DRT_USING_ARM_LIBC -DUSE_STDPERIPH_DRIVER --omf_browse=.\build\stm32f10x_rcc.crf Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;216      */
;;;217    void RCC_DeInit(void)
000000  48fe              LDR      r0,|L1.1020|
;;;218    {
;;;219      /* Set HSION bit */
;;;220      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  49fc              LDR      r1,|L1.1020|
00000a  6008              STR      r0,[r1,#0]
;;;221    
;;;222      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;223    #ifndef STM32F10X_CL
;;;224      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  49fb              LDR      r1,|L1.1024|
000012  4008              ANDS     r0,r0,r1
000014  49f9              LDR      r1,|L1.1020|
000016  6048              STR      r0,[r1,#4]
;;;225    #else
;;;226      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;227    #endif /* STM32F10X_CL */   
;;;228      
;;;229      /* Reset HSEON, CSSON and PLLON bits */
;;;230      RCC->CR &= (uint32_t)0xFEF6FFFF;
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  49f9              LDR      r1,|L1.1028|
00001e  4008              ANDS     r0,r0,r1
000020  49f6              LDR      r1,|L1.1020|
000022  6008              STR      r0,[r1,#0]
;;;231    
;;;232      /* Reset HSEBYP bit */
;;;233      RCC->CR &= (uint32_t)0xFFFBFFFF;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f4202080          BIC      r0,r0,#0x40000
00002c  6008              STR      r0,[r1,#0]
;;;234    
;;;235      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;236      RCC->CFGR &= (uint32_t)0xFF80FFFF;
00002e  4608              MOV      r0,r1
000030  6840              LDR      r0,[r0,#4]
000032  f42000fe          BIC      r0,r0,#0x7f0000
000036  6048              STR      r0,[r1,#4]
;;;237    
;;;238    #ifdef STM32F10X_CL
;;;239      /* Reset PLL2ON and PLL3ON bits */
;;;240      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;241    
;;;242      /* Disable all interrupts and clear pending bits  */
;;;243      RCC->CIR = 0x00FF0000;
;;;244    
;;;245      /* Reset CFGR2 register */
;;;246      RCC->CFGR2 = 0x00000000;
;;;247    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;248      /* Disable all interrupts and clear pending bits  */
;;;249      RCC->CIR = 0x009F0000;
;;;250    
;;;251      /* Reset CFGR2 register */
;;;252      RCC->CFGR2 = 0x00000000;      
;;;253    #else
;;;254      /* Disable all interrupts and clear pending bits  */
;;;255      RCC->CIR = 0x009F0000;
000038  f44f001f          MOV      r0,#0x9f0000
00003c  6088              STR      r0,[r1,#8]
;;;256    #endif /* STM32F10X_CL */
;;;257    
;;;258    }
00003e  4770              BX       lr
;;;259    
                          ENDP

                  RCC_HSEConfig PROC
;;;269      */
;;;270    void RCC_HSEConfig(uint32_t RCC_HSE)
000040  b510              PUSH     {r4,lr}
;;;271    {
000042  4604              MOV      r4,r0
;;;272      /* Check the parameters */
;;;273      assert_param(IS_RCC_HSE(RCC_HSE));
000044  b12c              CBZ      r4,|L1.82|
000046  f5b43f80          CMP      r4,#0x10000
00004a  d002              BEQ      |L1.82|
00004c  f5b42f80          CMP      r4,#0x40000
000050  d100              BNE      |L1.84|
                  |L1.82|
000052  e004              B        |L1.94|
                  |L1.84|
000054  f2401111          MOV      r1,#0x111
000058  a0eb              ADR      r0,|L1.1032|
00005a  f7fffffe          BL       assert_failed
                  |L1.94|
;;;274      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;275      /* Reset HSEON bit */
;;;276      RCC->CR &= CR_HSEON_Reset;
00005e  48e7              LDR      r0,|L1.1020|
000060  6800              LDR      r0,[r0,#0]
000062  f4203080          BIC      r0,r0,#0x10000
000066  49e5              LDR      r1,|L1.1020|
000068  6008              STR      r0,[r1,#0]
;;;277      /* Reset HSEBYP bit */
;;;278      RCC->CR &= CR_HSEBYP_Reset;
00006a  4608              MOV      r0,r1
00006c  6800              LDR      r0,[r0,#0]
00006e  f4202080          BIC      r0,r0,#0x40000
000072  6008              STR      r0,[r1,#0]
;;;279      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;280      switch(RCC_HSE)
000074  f5b43f80          CMP      r4,#0x10000
000078  d003              BEQ      |L1.130|
00007a  f5b42f80          CMP      r4,#0x40000
00007e  d10e              BNE      |L1.158|
000080  e006              B        |L1.144|
                  |L1.130|
;;;281      {
;;;282        case RCC_HSE_ON:
;;;283          /* Set HSEON bit */
;;;284          RCC->CR |= CR_HSEON_Set;
000082  48de              LDR      r0,|L1.1020|
000084  6800              LDR      r0,[r0,#0]
000086  f4403080          ORR      r0,r0,#0x10000
00008a  49dc              LDR      r1,|L1.1020|
00008c  6008              STR      r0,[r1,#0]
;;;285          break;
00008e  e007              B        |L1.160|
                  |L1.144|
;;;286          
;;;287        case RCC_HSE_Bypass:
;;;288          /* Set HSEBYP and HSEON bits */
;;;289          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000090  48da              LDR      r0,|L1.1020|
000092  6800              LDR      r0,[r0,#0]
000094  f44020a0          ORR      r0,r0,#0x50000
000098  49d8              LDR      r1,|L1.1020|
00009a  6008              STR      r0,[r1,#0]
;;;290          break;
00009c  e000              B        |L1.160|
                  |L1.158|
;;;291          
;;;292        default:
;;;293          break;
00009e  bf00              NOP      
                  |L1.160|
0000a0  bf00              NOP                            ;285
;;;294      }
;;;295    }
0000a2  bd10              POP      {r4,pc}
;;;296    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;1325     */
;;;1326   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
0000a4  e92d41f0          PUSH     {r4-r8,lr}
;;;1327   {
0000a8  4604              MOV      r4,r0
;;;1328     uint32_t tmp = 0;
0000aa  2500              MOVS     r5,#0
;;;1329     uint32_t statusreg = 0;
0000ac  2600              MOVS     r6,#0
;;;1330     FlagStatus bitstatus = RESET;
0000ae  2700              MOVS     r7,#0
;;;1331     /* Check the parameters */
;;;1332     assert_param(IS_RCC_FLAG(RCC_FLAG));
0000b0  2c21              CMP      r4,#0x21
0000b2  d013              BEQ      |L1.220|
0000b4  2c31              CMP      r4,#0x31
0000b6  d011              BEQ      |L1.220|
0000b8  2c39              CMP      r4,#0x39
0000ba  d00f              BEQ      |L1.220|
0000bc  2c41              CMP      r4,#0x41
0000be  d00d              BEQ      |L1.220|
0000c0  2c61              CMP      r4,#0x61
0000c2  d00b              BEQ      |L1.220|
0000c4  2c7a              CMP      r4,#0x7a
0000c6  d009              BEQ      |L1.220|
0000c8  2c7b              CMP      r4,#0x7b
0000ca  d007              BEQ      |L1.220|
0000cc  2c7c              CMP      r4,#0x7c
0000ce  d005              BEQ      |L1.220|
0000d0  2c7d              CMP      r4,#0x7d
0000d2  d003              BEQ      |L1.220|
0000d4  2c7e              CMP      r4,#0x7e
0000d6  d001              BEQ      |L1.220|
0000d8  2c7f              CMP      r4,#0x7f
0000da  d100              BNE      |L1.222|
                  |L1.220|
0000dc  e004              B        |L1.232|
                  |L1.222|
0000de  f2405134          MOV      r1,#0x534
0000e2  a0c9              ADR      r0,|L1.1032|
0000e4  f7fffffe          BL       assert_failed
                  |L1.232|
;;;1333   
;;;1334     /* Get the RCC register index */
;;;1335     tmp = RCC_FLAG >> 5;
0000e8  1165              ASRS     r5,r4,#5
;;;1336     if (tmp == 1)               /* The flag to check is in CR register */
0000ea  2d01              CMP      r5,#1
0000ec  d102              BNE      |L1.244|
;;;1337     {
;;;1338       statusreg = RCC->CR;
0000ee  48c3              LDR      r0,|L1.1020|
0000f0  6806              LDR      r6,[r0,#0]
0000f2  e006              B        |L1.258|
                  |L1.244|
;;;1339     }
;;;1340     else if (tmp == 2)          /* The flag to check is in BDCR register */
0000f4  2d02              CMP      r5,#2
0000f6  d102              BNE      |L1.254|
;;;1341     {
;;;1342       statusreg = RCC->BDCR;
0000f8  48c0              LDR      r0,|L1.1020|
0000fa  6a06              LDR      r6,[r0,#0x20]
0000fc  e001              B        |L1.258|
                  |L1.254|
;;;1343     }
;;;1344     else                       /* The flag to check is in CSR register */
;;;1345     {
;;;1346       statusreg = RCC->CSR;
0000fe  48bf              LDR      r0,|L1.1020|
000100  6a46              LDR      r6,[r0,#0x24]
                  |L1.258|
;;;1347     }
;;;1348   
;;;1349     /* Get the flag position */
;;;1350     tmp = RCC_FLAG & FLAG_Mask;
000102  f004051f          AND      r5,r4,#0x1f
;;;1351     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000106  2001              MOVS     r0,#1
000108  40a8              LSLS     r0,r0,r5
00010a  4030              ANDS     r0,r0,r6
00010c  b108              CBZ      r0,|L1.274|
;;;1352     {
;;;1353       bitstatus = SET;
00010e  2701              MOVS     r7,#1
000110  e000              B        |L1.276|
                  |L1.274|
;;;1354     }
;;;1355     else
;;;1356     {
;;;1357       bitstatus = RESET;
000112  2700              MOVS     r7,#0
                  |L1.276|
;;;1358     }
;;;1359   
;;;1360     /* Return the flag status */
;;;1361     return bitstatus;
000114  4638              MOV      r0,r7
;;;1362   }
000116  e8bd81f0          POP      {r4-r8,pc}
;;;1363   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;303      */
;;;304    ErrorStatus RCC_WaitForHSEStartUp(void)
00011a  b538              PUSH     {r3-r5,lr}
;;;305    {
;;;306      __IO uint32_t StartUpCounter = 0;
00011c  2000              MOVS     r0,#0
00011e  9000              STR      r0,[sp,#0]
;;;307      ErrorStatus status = ERROR;
000120  2400              MOVS     r4,#0
;;;308      FlagStatus HSEStatus = RESET;
000122  2500              MOVS     r5,#0
;;;309      
;;;310      /* Wait till HSE is ready and if Time out is reached exit */
;;;311      do
000124  bf00              NOP      
                  |L1.294|
;;;312      {
;;;313        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
000126  2031              MOVS     r0,#0x31
000128  f7fffffe          BL       RCC_GetFlagStatus
00012c  4605              MOV      r5,r0
;;;314        StartUpCounter++;  
00012e  9800              LDR      r0,[sp,#0]
000130  1c40              ADDS     r0,r0,#1
000132  9000              STR      r0,[sp,#0]
;;;315      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
000134  9800              LDR      r0,[sp,#0]
000136  f5b06fa0          CMP      r0,#0x500
00013a  d001              BEQ      |L1.320|
00013c  2d00              CMP      r5,#0
00013e  d0f2              BEQ      |L1.294|
                  |L1.320|
;;;316      
;;;317      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000140  2031              MOVS     r0,#0x31
000142  f7fffffe          BL       RCC_GetFlagStatus
000146  b108              CBZ      r0,|L1.332|
;;;318      {
;;;319        status = SUCCESS;
000148  2401              MOVS     r4,#1
00014a  e000              B        |L1.334|
                  |L1.332|
;;;320      }
;;;321      else
;;;322      {
;;;323        status = ERROR;
00014c  2400              MOVS     r4,#0
                  |L1.334|
;;;324      }  
;;;325      return (status);
00014e  4620              MOV      r0,r4
;;;326    }
000150  bd38              POP      {r3-r5,pc}
;;;327    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;333      */
;;;334    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000152  b570              PUSH     {r4-r6,lr}
;;;335    {
000154  4604              MOV      r4,r0
;;;336      uint32_t tmpreg = 0;
000156  2500              MOVS     r5,#0
;;;337      /* Check the parameters */
;;;338      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
000158  2c1f              CMP      r4,#0x1f
00015a  dc00              BGT      |L1.350|
00015c  e004              B        |L1.360|
                  |L1.350|
00015e  f44f71a9          MOV      r1,#0x152
000162  a0a9              ADR      r0,|L1.1032|
000164  f7fffffe          BL       assert_failed
                  |L1.360|
;;;339      tmpreg = RCC->CR;
000168  48a4              LDR      r0,|L1.1020|
00016a  6805              LDR      r5,[r0,#0]
;;;340      /* Clear HSITRIM[4:0] bits */
;;;341      tmpreg &= CR_HSITRIM_Mask;
00016c  f02505f8          BIC      r5,r5,#0xf8
;;;342      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;343      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000170  ea4505c4          ORR      r5,r5,r4,LSL #3
;;;344      /* Store the new value */
;;;345      RCC->CR = tmpreg;
000174  6005              STR      r5,[r0,#0]
;;;346    }
000176  bd70              POP      {r4-r6,pc}
;;;347    
                          ENDP

                  RCC_HSICmd PROC
;;;353      */
;;;354    void RCC_HSICmd(FunctionalState NewState)
000178  b510              PUSH     {r4,lr}
;;;355    {
00017a  4604              MOV      r4,r0
;;;356      /* Check the parameters */
;;;357      assert_param(IS_FUNCTIONAL_STATE(NewState));
00017c  b10c              CBZ      r4,|L1.386|
00017e  2c01              CMP      r4,#1
000180  d100              BNE      |L1.388|
                  |L1.386|
000182  e004              B        |L1.398|
                  |L1.388|
000184  f2401165          MOV      r1,#0x165
000188  a09f              ADR      r0,|L1.1032|
00018a  f7fffffe          BL       assert_failed
                  |L1.398|
;;;358      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
00018e  48ad              LDR      r0,|L1.1092|
000190  6004              STR      r4,[r0,#0]
;;;359    }
000192  bd10              POP      {r4,pc}
;;;360    
                          ENDP

                  RCC_PLLConfig PROC
;;;377      */
;;;378    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000194  b570              PUSH     {r4-r6,lr}
;;;379    {
000196  4605              MOV      r5,r0
000198  460c              MOV      r4,r1
;;;380      uint32_t tmpreg = 0;
00019a  2600              MOVS     r6,#0
;;;381    
;;;382      /* Check the parameters */
;;;383      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
00019c  b12d              CBZ      r5,|L1.426|
00019e  f5b53f80          CMP      r5,#0x10000
0001a2  d002              BEQ      |L1.426|
0001a4  f5b53f40          CMP      r5,#0x30000
0001a8  d100              BNE      |L1.428|
                  |L1.426|
0001aa  e004              B        |L1.438|
                  |L1.428|
0001ac  f240117f          MOV      r1,#0x17f
0001b0  a095              ADR      r0,|L1.1032|
0001b2  f7fffffe          BL       assert_failed
                  |L1.438|
;;;384      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
0001b6  b34c              CBZ      r4,|L1.524|
0001b8  f5b42f80          CMP      r4,#0x40000
0001bc  d026              BEQ      |L1.524|
0001be  f5b42f00          CMP      r4,#0x80000
0001c2  d023              BEQ      |L1.524|
0001c4  f5b42f40          CMP      r4,#0xc0000
0001c8  d020              BEQ      |L1.524|
0001ca  f5b41f80          CMP      r4,#0x100000
0001ce  d01d              BEQ      |L1.524|
0001d0  f5b41fa0          CMP      r4,#0x140000
0001d4  d01a              BEQ      |L1.524|
0001d6  f5b41fc0          CMP      r4,#0x180000
0001da  d017              BEQ      |L1.524|
0001dc  f5b41fe0          CMP      r4,#0x1c0000
0001e0  d014              BEQ      |L1.524|
0001e2  f5b41f00          CMP      r4,#0x200000
0001e6  d011              BEQ      |L1.524|
0001e8  f5b41f10          CMP      r4,#0x240000
0001ec  d00e              BEQ      |L1.524|
0001ee  f5b41f20          CMP      r4,#0x280000
0001f2  d00b              BEQ      |L1.524|
0001f4  f5b41f30          CMP      r4,#0x2c0000
0001f8  d008              BEQ      |L1.524|
0001fa  f5b41f40          CMP      r4,#0x300000
0001fe  d005              BEQ      |L1.524|
000200  f5b41f50          CMP      r4,#0x340000
000204  d002              BEQ      |L1.524|
000206  f5b41f60          CMP      r4,#0x380000
00020a  d100              BNE      |L1.526|
                  |L1.524|
00020c  e004              B        |L1.536|
                  |L1.526|
00020e  f44f71c0          MOV      r1,#0x180
000212  a07d              ADR      r0,|L1.1032|
000214  f7fffffe          BL       assert_failed
                  |L1.536|
;;;385    
;;;386      tmpreg = RCC->CFGR;
000218  4878              LDR      r0,|L1.1020|
00021a  6846              LDR      r6,[r0,#4]
;;;387      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;388      tmpreg &= CFGR_PLL_Mask;
00021c  f426167c          BIC      r6,r6,#0x3f0000
;;;389      /* Set the PLL configuration bits */
;;;390      tmpreg |= RCC_PLLSource | RCC_PLLMul;
000220  ea450004          ORR      r0,r5,r4
000224  4306              ORRS     r6,r6,r0
;;;391      /* Store the new value */
;;;392      RCC->CFGR = tmpreg;
000226  4875              LDR      r0,|L1.1020|
000228  6046              STR      r6,[r0,#4]
;;;393    }
00022a  bd70              POP      {r4-r6,pc}
;;;394    
                          ENDP

                  RCC_PLLCmd PROC
;;;400      */
;;;401    void RCC_PLLCmd(FunctionalState NewState)
00022c  b510              PUSH     {r4,lr}
;;;402    {
00022e  4604              MOV      r4,r0
;;;403      /* Check the parameters */
;;;404      assert_param(IS_FUNCTIONAL_STATE(NewState));
000230  b10c              CBZ      r4,|L1.566|
000232  2c01              CMP      r4,#1
000234  d100              BNE      |L1.568|
                  |L1.566|
000236  e004              B        |L1.578|
                  |L1.568|
000238  f44f71ca          MOV      r1,#0x194
00023c  a072              ADR      r0,|L1.1032|
00023e  f7fffffe          BL       assert_failed
                  |L1.578|
;;;405    
;;;406      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000242  4880              LDR      r0,|L1.1092|
000244  6604              STR      r4,[r0,#0x60]
;;;407    }
000246  bd10              POP      {r4,pc}
;;;408    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;563      */
;;;564    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000248  b570              PUSH     {r4-r6,lr}
;;;565    {
00024a  4604              MOV      r4,r0
;;;566      uint32_t tmpreg = 0;
00024c  2500              MOVS     r5,#0
;;;567      /* Check the parameters */
;;;568      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
00024e  b11c              CBZ      r4,|L1.600|
000250  2c01              CMP      r4,#1
000252  d001              BEQ      |L1.600|
000254  2c02              CMP      r4,#2
000256  d100              BNE      |L1.602|
                  |L1.600|
000258  e004              B        |L1.612|
                  |L1.602|
00025a  f44f710e          MOV      r1,#0x238
00025e  a06a              ADR      r0,|L1.1032|
000260  f7fffffe          BL       assert_failed
                  |L1.612|
;;;569      tmpreg = RCC->CFGR;
000264  4865              LDR      r0,|L1.1020|
000266  6845              LDR      r5,[r0,#4]
;;;570      /* Clear SW[1:0] bits */
;;;571      tmpreg &= CFGR_SW_Mask;
000268  f0250503          BIC      r5,r5,#3
;;;572      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;573      tmpreg |= RCC_SYSCLKSource;
00026c  4325              ORRS     r5,r5,r4
;;;574      /* Store the new value */
;;;575      RCC->CFGR = tmpreg;
00026e  6045              STR      r5,[r0,#4]
;;;576    }
000270  bd70              POP      {r4-r6,pc}
;;;577    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;586      */
;;;587    uint8_t RCC_GetSYSCLKSource(void)
000272  4862              LDR      r0,|L1.1020|
;;;588    {
;;;589      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000274  6840              LDR      r0,[r0,#4]
000276  f000000c          AND      r0,r0,#0xc
;;;590    }
00027a  4770              BX       lr
;;;591    
                          ENDP

                  RCC_HCLKConfig PROC
;;;607      */
;;;608    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
00027c  b570              PUSH     {r4-r6,lr}
;;;609    {
00027e  4604              MOV      r4,r0
;;;610      uint32_t tmpreg = 0;
000280  2500              MOVS     r5,#0
;;;611      /* Check the parameters */
;;;612      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
000282  b17c              CBZ      r4,|L1.676|
000284  2c80              CMP      r4,#0x80
000286  d00d              BEQ      |L1.676|
000288  2c90              CMP      r4,#0x90
00028a  d00b              BEQ      |L1.676|
00028c  2ca0              CMP      r4,#0xa0
00028e  d009              BEQ      |L1.676|
000290  2cb0              CMP      r4,#0xb0
000292  d007              BEQ      |L1.676|
000294  2cc0              CMP      r4,#0xc0
000296  d005              BEQ      |L1.676|
000298  2cd0              CMP      r4,#0xd0
00029a  d003              BEQ      |L1.676|
00029c  2ce0              CMP      r4,#0xe0
00029e  d001              BEQ      |L1.676|
0002a0  2cf0              CMP      r4,#0xf0
0002a2  d100              BNE      |L1.678|
                  |L1.676|
0002a4  e004              B        |L1.688|
                  |L1.678|
0002a6  f44f7119          MOV      r1,#0x264
0002aa  a057              ADR      r0,|L1.1032|
0002ac  f7fffffe          BL       assert_failed
                  |L1.688|
;;;613      tmpreg = RCC->CFGR;
0002b0  4852              LDR      r0,|L1.1020|
0002b2  6845              LDR      r5,[r0,#4]
;;;614      /* Clear HPRE[3:0] bits */
;;;615      tmpreg &= CFGR_HPRE_Reset_Mask;
0002b4  f02505f0          BIC      r5,r5,#0xf0
;;;616      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;617      tmpreg |= RCC_SYSCLK;
0002b8  4325              ORRS     r5,r5,r4
;;;618      /* Store the new value */
;;;619      RCC->CFGR = tmpreg;
0002ba  6045              STR      r5,[r0,#4]
;;;620    }
0002bc  bd70              POP      {r4-r6,pc}
;;;621    
                          ENDP

                  RCC_PCLK1Config PROC
;;;633      */
;;;634    void RCC_PCLK1Config(uint32_t RCC_HCLK)
0002be  b570              PUSH     {r4-r6,lr}
;;;635    {
0002c0  4604              MOV      r4,r0
;;;636      uint32_t tmpreg = 0;
0002c2  2500              MOVS     r5,#0
;;;637      /* Check the parameters */
;;;638      assert_param(IS_RCC_PCLK(RCC_HCLK));
0002c4  b15c              CBZ      r4,|L1.734|
0002c6  f5b46f80          CMP      r4,#0x400
0002ca  d008              BEQ      |L1.734|
0002cc  f5b46fa0          CMP      r4,#0x500
0002d0  d005              BEQ      |L1.734|
0002d2  f5b46fc0          CMP      r4,#0x600
0002d6  d002              BEQ      |L1.734|
0002d8  f5b46fe0          CMP      r4,#0x700
0002dc  d100              BNE      |L1.736|
                  |L1.734|
0002de  e004              B        |L1.746|
                  |L1.736|
0002e0  f240217e          MOV      r1,#0x27e
0002e4  a048              ADR      r0,|L1.1032|
0002e6  f7fffffe          BL       assert_failed
                  |L1.746|
;;;639      tmpreg = RCC->CFGR;
0002ea  4844              LDR      r0,|L1.1020|
0002ec  6845              LDR      r5,[r0,#4]
;;;640      /* Clear PPRE1[2:0] bits */
;;;641      tmpreg &= CFGR_PPRE1_Reset_Mask;
0002ee  f42565e0          BIC      r5,r5,#0x700
;;;642      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;643      tmpreg |= RCC_HCLK;
0002f2  4325              ORRS     r5,r5,r4
;;;644      /* Store the new value */
;;;645      RCC->CFGR = tmpreg;
0002f4  6045              STR      r5,[r0,#4]
;;;646    }
0002f6  bd70              POP      {r4-r6,pc}
;;;647    
                          ENDP

                  RCC_PCLK2Config PROC
;;;659      */
;;;660    void RCC_PCLK2Config(uint32_t RCC_HCLK)
0002f8  b570              PUSH     {r4-r6,lr}
;;;661    {
0002fa  4604              MOV      r4,r0
;;;662      uint32_t tmpreg = 0;
0002fc  2500              MOVS     r5,#0
;;;663      /* Check the parameters */
;;;664      assert_param(IS_RCC_PCLK(RCC_HCLK));
0002fe  b15c              CBZ      r4,|L1.792|
000300  f5b46f80          CMP      r4,#0x400
000304  d008              BEQ      |L1.792|
000306  f5b46fa0          CMP      r4,#0x500
00030a  d005              BEQ      |L1.792|
00030c  f5b46fc0          CMP      r4,#0x600
000310  d002              BEQ      |L1.792|
000312  f5b46fe0          CMP      r4,#0x700
000316  d100              BNE      |L1.794|
                  |L1.792|
000318  e004              B        |L1.804|
                  |L1.794|
00031a  f44f7126          MOV      r1,#0x298
00031e  a03a              ADR      r0,|L1.1032|
000320  f7fffffe          BL       assert_failed
                  |L1.804|
;;;665      tmpreg = RCC->CFGR;
000324  4835              LDR      r0,|L1.1020|
000326  6845              LDR      r5,[r0,#4]
;;;666      /* Clear PPRE2[2:0] bits */
;;;667      tmpreg &= CFGR_PPRE2_Reset_Mask;
000328  f4255560          BIC      r5,r5,#0x3800
;;;668      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;669      tmpreg |= RCC_HCLK << 3;
00032c  ea4505c4          ORR      r5,r5,r4,LSL #3
;;;670      /* Store the new value */
;;;671      RCC->CFGR = tmpreg;
000330  6045              STR      r5,[r0,#4]
;;;672    }
000332  bd70              POP      {r4-r6,pc}
;;;673    
                          ENDP

                  RCC_ITConfig PROC
;;;699      */
;;;700    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000334  b570              PUSH     {r4-r6,lr}
;;;701    {
000336  4604              MOV      r4,r0
000338  460d              MOV      r5,r1
;;;702      /* Check the parameters */
;;;703      assert_param(IS_RCC_IT(RCC_IT));
00033a  f00400e0          AND      r0,r4,#0xe0
00033e  b908              CBNZ     r0,|L1.836|
000340  b104              CBZ      r4,|L1.836|
000342  e004              B        |L1.846|
                  |L1.836|
000344  f24021bf          MOV      r1,#0x2bf
000348  a02f              ADR      r0,|L1.1032|
00034a  f7fffffe          BL       assert_failed
                  |L1.846|
;;;704      assert_param(IS_FUNCTIONAL_STATE(NewState));
00034e  b10d              CBZ      r5,|L1.852|
000350  2d01              CMP      r5,#1
000352  d100              BNE      |L1.854|
                  |L1.852|
000354  e004              B        |L1.864|
                  |L1.854|
000356  f44f7130          MOV      r1,#0x2c0
00035a  a02b              ADR      r0,|L1.1032|
00035c  f7fffffe          BL       assert_failed
                  |L1.864|
;;;705      if (NewState != DISABLE)
000360  b12d              CBZ      r5,|L1.878|
;;;706      {
;;;707        /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
;;;708        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000362  4826              LDR      r0,|L1.1020|
000364  7a40              LDRB     r0,[r0,#9]
000366  4320              ORRS     r0,r0,r4
000368  4924              LDR      r1,|L1.1020|
00036a  7248              STRB     r0,[r1,#9]
00036c  e004              B        |L1.888|
                  |L1.878|
;;;709      }
;;;710      else
;;;711      {
;;;712        /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
;;;713        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
00036e  4823              LDR      r0,|L1.1020|
000370  7a40              LDRB     r0,[r0,#9]
000372  43a0              BICS     r0,r0,r4
000374  4921              LDR      r1,|L1.1020|
000376  7248              STRB     r0,[r1,#9]
                  |L1.888|
;;;714      }
;;;715    }
000378  bd70              POP      {r4-r6,pc}
;;;716    
                          ENDP

                  RCC_USBCLKConfig PROC
;;;727      */
;;;728    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
00037a  b510              PUSH     {r4,lr}
;;;729    {
00037c  4604              MOV      r4,r0
;;;730      /* Check the parameters */
;;;731      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
00037e  b10c              CBZ      r4,|L1.900|
000380  2c01              CMP      r4,#1
000382  d100              BNE      |L1.902|
                  |L1.900|
000384  e004              B        |L1.912|
                  |L1.902|
000386  f24021db          MOV      r1,#0x2db
00038a  a01f              ADR      r0,|L1.1032|
00038c  f7fffffe          BL       assert_failed
                  |L1.912|
;;;732    
;;;733      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000390  482c              LDR      r0,|L1.1092|
000392  30d8              ADDS     r0,r0,#0xd8
000394  6004              STR      r4,[r0,#0]
;;;734    }
000396  bd10              POP      {r4,pc}
;;;735    #else
                          ENDP

                  RCC_ADCCLKConfig PROC
;;;765      */
;;;766    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000398  b570              PUSH     {r4-r6,lr}
;;;767    {
00039a  4604              MOV      r4,r0
;;;768      uint32_t tmpreg = 0;
00039c  2500              MOVS     r5,#0
;;;769      /* Check the parameters */
;;;770      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
00039e  b144              CBZ      r4,|L1.946|
0003a0  f5b44f80          CMP      r4,#0x4000
0003a4  d005              BEQ      |L1.946|
0003a6  f5b44f00          CMP      r4,#0x8000
0003aa  d002              BEQ      |L1.946|
0003ac  f5b44f40          CMP      r4,#0xc000
0003b0  d100              BNE      |L1.948|
                  |L1.946|
0003b2  e004              B        |L1.958|
                  |L1.948|
0003b4  f2403102          MOV      r1,#0x302
0003b8  a013              ADR      r0,|L1.1032|
0003ba  f7fffffe          BL       assert_failed
                  |L1.958|
;;;771      tmpreg = RCC->CFGR;
0003be  480f              LDR      r0,|L1.1020|
0003c0  6845              LDR      r5,[r0,#4]
;;;772      /* Clear ADCPRE[1:0] bits */
;;;773      tmpreg &= CFGR_ADCPRE_Reset_Mask;
0003c2  f4254540          BIC      r5,r5,#0xc000
;;;774      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;775      tmpreg |= RCC_PCLK2;
0003c6  4325              ORRS     r5,r5,r4
;;;776      /* Store the new value */
;;;777      RCC->CFGR = tmpreg;
0003c8  6045              STR      r5,[r0,#4]
;;;778    }
0003ca  bd70              POP      {r4-r6,pc}
;;;779    
                          ENDP

                  RCC_LSEConfig PROC
;;;828      */
;;;829    void RCC_LSEConfig(uint8_t RCC_LSE)
0003cc  b510              PUSH     {r4,lr}
;;;830    {
0003ce  4604              MOV      r4,r0
;;;831      /* Check the parameters */
;;;832      assert_param(IS_RCC_LSE(RCC_LSE));
0003d0  b11c              CBZ      r4,|L1.986|
0003d2  2c01              CMP      r4,#1
0003d4  d001              BEQ      |L1.986|
0003d6  2c04              CMP      r4,#4
0003d8  d100              BNE      |L1.988|
                  |L1.986|
0003da  e004              B        |L1.998|
                  |L1.988|
0003dc  f44f7150          MOV      r1,#0x340
0003e0  a009              ADR      r0,|L1.1032|
0003e2  f7fffffe          BL       assert_failed
                  |L1.998|
;;;833      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;834      /* Reset LSEON bit */
;;;835      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0003e6  2000              MOVS     r0,#0
0003e8  4904              LDR      r1,|L1.1020|
0003ea  3120              ADDS     r1,r1,#0x20
0003ec  7008              STRB     r0,[r1,#0]
;;;836      /* Reset LSEBYP bit */
;;;837      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0003ee  4903              LDR      r1,|L1.1020|
0003f0  f8810020          STRB     r0,[r1,#0x20]
;;;838      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;839      switch(RCC_LSE)
0003f4  2c01              CMP      r4,#1
0003f6  d029              BEQ      |L1.1100|
0003f8  2c04              CMP      r4,#4
0003fa  e025              B        |L1.1096|
                  |L1.1020|
                          DCD      0x40021000
                  |L1.1024|
                          DCD      0xf8ff0000
                  |L1.1028|
                          DCD      0xfef6ffff
                  |L1.1032|
000408  4c696272          DCB      "Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_r"
00040c  61726965
000410  735c5354
000414  4d333246
000418  3130785f
00041c  53746450
000420  65726970
000424  685f4472
000428  69766572
00042c  5c737263
000430  5c73746d
000434  33326631
000438  30785f72
00043c  63632e63          DCB      "cc.c",0
000440  00      
000441  00                DCB      0
000442  00                DCB      0
000443  00                DCB      0
                  |L1.1092|
                          DCD      0x42420000
                  |L1.1096|
000448  d108              BNE      |L1.1116|
00044a  e003              B        |L1.1108|
                  |L1.1100|
;;;840      {
;;;841        case RCC_LSE_ON:
;;;842          /* Set LSEON bit */
;;;843          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
00044c  2001              MOVS     r0,#1
00044e  49f4              LDR      r1,|L1.2080|
000450  7008              STRB     r0,[r1,#0]
;;;844          break;
000452  e004              B        |L1.1118|
                  |L1.1108|
;;;845          
;;;846        case RCC_LSE_Bypass:
;;;847          /* Set LSEBYP and LSEON bits */
;;;848          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000454  2005              MOVS     r0,#5
000456  49f2              LDR      r1,|L1.2080|
000458  7008              STRB     r0,[r1,#0]
;;;849          break;            
00045a  e000              B        |L1.1118|
                  |L1.1116|
;;;850          
;;;851        default:
;;;852          break;      
00045c  bf00              NOP      
                  |L1.1118|
00045e  bf00              NOP                            ;844
;;;853      }
;;;854    }
000460  bd10              POP      {r4,pc}
;;;855    
                          ENDP

                  RCC_LSICmd PROC
;;;861      */
;;;862    void RCC_LSICmd(FunctionalState NewState)
000462  b510              PUSH     {r4,lr}
;;;863    {
000464  4604              MOV      r4,r0
;;;864      /* Check the parameters */
;;;865      assert_param(IS_FUNCTIONAL_STATE(NewState));
000466  b10c              CBZ      r4,|L1.1132|
000468  2c01              CMP      r4,#1
00046a  d100              BNE      |L1.1134|
                  |L1.1132|
00046c  e005              B        |L1.1146|
                  |L1.1134|
00046e  f2403161          MOV      r1,#0x361
000472  f2af006c          ADR      r0,|L1.1032|
000476  f7fffffe          BL       assert_failed
                  |L1.1146|
;;;866      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
00047a  48ea              LDR      r0,|L1.2084|
00047c  6004              STR      r4,[r0,#0]
;;;867    }
00047e  bd10              POP      {r4,pc}
;;;868    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;878      */
;;;879    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000480  b510              PUSH     {r4,lr}
;;;880    {
000482  4604              MOV      r4,r0
;;;881      /* Check the parameters */
;;;882      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
000484  f5b47f80          CMP      r4,#0x100
000488  d005              BEQ      |L1.1174|
00048a  f5b47f00          CMP      r4,#0x200
00048e  d002              BEQ      |L1.1174|
000490  f5b47f40          CMP      r4,#0x300
000494  d100              BNE      |L1.1176|
                  |L1.1174|
000496  e005              B        |L1.1188|
                  |L1.1176|
000498  f2403172          MOV      r1,#0x372
00049c  f2af0098          ADR      r0,|L1.1032|
0004a0  f7fffffe          BL       assert_failed
                  |L1.1188|
;;;883      /* Select the RTC clock source */
;;;884      RCC->BDCR |= RCC_RTCCLKSource;
0004a4  48de              LDR      r0,|L1.2080|
0004a6  3820              SUBS     r0,r0,#0x20
0004a8  6a00              LDR      r0,[r0,#0x20]
0004aa  4320              ORRS     r0,r0,r4
0004ac  49dc              LDR      r1,|L1.2080|
0004ae  3920              SUBS     r1,r1,#0x20
0004b0  6208              STR      r0,[r1,#0x20]
;;;885    }
0004b2  bd10              POP      {r4,pc}
;;;886    
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;892      */
;;;893    void RCC_RTCCLKCmd(FunctionalState NewState)
0004b4  b510              PUSH     {r4,lr}
;;;894    {
0004b6  4604              MOV      r4,r0
;;;895      /* Check the parameters */
;;;896      assert_param(IS_FUNCTIONAL_STATE(NewState));
0004b8  b10c              CBZ      r4,|L1.1214|
0004ba  2c01              CMP      r4,#1
0004bc  d100              BNE      |L1.1216|
                  |L1.1214|
0004be  e005              B        |L1.1228|
                  |L1.1216|
0004c0  f44f7160          MOV      r1,#0x380
0004c4  f2af00c0          ADR      r0,|L1.1032|
0004c8  f7fffffe          BL       assert_failed
                  |L1.1228|
;;;897      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
0004cc  48d5              LDR      r0,|L1.2084|
0004ce  3844              SUBS     r0,r0,#0x44
0004d0  6004              STR      r4,[r0,#0]
;;;898    }
0004d2  bd10              POP      {r4,pc}
;;;899    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;907      */
;;;908    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
0004d4  b530              PUSH     {r4,r5,lr}
;;;909    {
;;;910      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
0004d6  2100              MOVS     r1,#0
0004d8  2200              MOVS     r2,#0
0004da  2400              MOVS     r4,#0
0004dc  2300              MOVS     r3,#0
;;;911    
;;;912    #ifdef  STM32F10X_CL
;;;913      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;914    #endif /* STM32F10X_CL */
;;;915    
;;;916    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;917      uint32_t prediv1factor = 0;
;;;918    #endif
;;;919        
;;;920      /* Get SYSCLK source -------------------------------------------------------*/
;;;921      tmp = RCC->CFGR & CFGR_SWS_Mask;
0004de  4dd0              LDR      r5,|L1.2080|
0004e0  3d20              SUBS     r5,r5,#0x20
0004e2  686d              LDR      r5,[r5,#4]
0004e4  f005010c          AND      r1,r5,#0xc
;;;922      
;;;923      switch (tmp)
0004e8  b121              CBZ      r1,|L1.1268|
0004ea  2904              CMP      r1,#4
0004ec  d005              BEQ      |L1.1274|
0004ee  2908              CMP      r1,#8
0004f0  d126              BNE      |L1.1344|
0004f2  e005              B        |L1.1280|
                  |L1.1268|
;;;924      {
;;;925        case 0x00:  /* HSI used as system clock */
;;;926          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
0004f4  4dcc              LDR      r5,|L1.2088|
0004f6  6005              STR      r5,[r0,#0]
;;;927          break;
0004f8  e025              B        |L1.1350|
                  |L1.1274|
;;;928        case 0x04:  /* HSE used as system clock */
;;;929          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
0004fa  4dcb              LDR      r5,|L1.2088|
0004fc  6005              STR      r5,[r0,#0]
;;;930          break;
0004fe  e022              B        |L1.1350|
                  |L1.1280|
;;;931        case 0x08:  /* PLL used as system clock */
;;;932    
;;;933          /* Get PLL clock source and multiplication factor ----------------------*/
;;;934          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
000500  4dc7              LDR      r5,|L1.2080|
000502  3d20              SUBS     r5,r5,#0x20
000504  686d              LDR      r5,[r5,#4]
000506  f4051270          AND      r2,r5,#0x3c0000
;;;935          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
00050a  4dc5              LDR      r5,|L1.2080|
00050c  3d20              SUBS     r5,r5,#0x20
00050e  686d              LDR      r5,[r5,#4]
000510  f4053480          AND      r4,r5,#0x10000
;;;936          
;;;937    #ifndef STM32F10X_CL      
;;;938          pllmull = ( pllmull >> 18) + 2;
000514  2502              MOVS     r5,#2
000516  eb054292          ADD      r2,r5,r2,LSR #18
;;;939          
;;;940          if (pllsource == 0x00)
00051a  b91c              CBNZ     r4,|L1.1316|
;;;941          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;942            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
00051c  4dc3              LDR      r5,|L1.2092|
00051e  4355              MULS     r5,r2,r5
000520  6005              STR      r5,[r0,#0]
000522  e00c              B        |L1.1342|
                  |L1.1316|
;;;943          }
;;;944          else
;;;945          {
;;;946     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;947           prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;948           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;949           RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
;;;950     #else
;;;951            /* HSE selected as PLL clock entry */
;;;952            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
000524  4dbe              LDR      r5,|L1.2080|
000526  3d20              SUBS     r5,r5,#0x20
000528  686d              LDR      r5,[r5,#4]
00052a  f4053500          AND      r5,r5,#0x20000
00052e  b11d              CBZ      r5,|L1.1336|
;;;953            {/* HSE oscillator clock divided by 2 */
;;;954              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
000530  4dbe              LDR      r5,|L1.2092|
000532  4355              MULS     r5,r2,r5
000534  6005              STR      r5,[r0,#0]
000536  e002              B        |L1.1342|
                  |L1.1336|
;;;955            }
;;;956            else
;;;957            {
;;;958              RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
000538  4dbb              LDR      r5,|L1.2088|
00053a  4355              MULS     r5,r2,r5
00053c  6005              STR      r5,[r0,#0]
                  |L1.1342|
;;;959            }
;;;960     #endif
;;;961          }
;;;962    #else
;;;963          pllmull = pllmull >> 18;
;;;964          
;;;965          if (pllmull != 0x0D)
;;;966          {
;;;967             pllmull += 2;
;;;968          }
;;;969          else
;;;970          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;971            pllmull = 13 / 2; 
;;;972          }
;;;973                
;;;974          if (pllsource == 0x00)
;;;975          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;976            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;977          }
;;;978          else
;;;979          {/* PREDIV1 selected as PLL clock entry */
;;;980            
;;;981            /* Get PREDIV1 clock source and division factor */
;;;982            prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
;;;983            prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;984            
;;;985            if (prediv1source == 0)
;;;986            { /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;987              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
;;;988            }
;;;989            else
;;;990            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;991              
;;;992              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;993              prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
;;;994              pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;995              RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;996            }
;;;997          }
;;;998    #endif /* STM32F10X_CL */ 
;;;999          break;
00053e  e002              B        |L1.1350|
                  |L1.1344|
;;;1000   
;;;1001       default:
;;;1002         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000540  4db9              LDR      r5,|L1.2088|
000542  6005              STR      r5,[r0,#0]
;;;1003         break;
000544  bf00              NOP      
                  |L1.1350|
000546  bf00              NOP                            ;927
;;;1004     }
;;;1005   
;;;1006     /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;1007     /* Get HCLK prescaler */
;;;1008     tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
000548  4db5              LDR      r5,|L1.2080|
00054a  3d20              SUBS     r5,r5,#0x20
00054c  686d              LDR      r5,[r5,#4]
00054e  f00501f0          AND      r1,r5,#0xf0
;;;1009     tmp = tmp >> 4;
000552  0909              LSRS     r1,r1,#4
;;;1010     presc = APBAHBPrescTable[tmp];
000554  4db6              LDR      r5,|L1.2096|
000556  5c6b              LDRB     r3,[r5,r1]
;;;1011     /* HCLK clock frequency */
;;;1012     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
000558  6805              LDR      r5,[r0,#0]
00055a  40dd              LSRS     r5,r5,r3
00055c  6045              STR      r5,[r0,#4]
;;;1013     /* Get PCLK1 prescaler */
;;;1014     tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
00055e  4db0              LDR      r5,|L1.2080|
000560  3d20              SUBS     r5,r5,#0x20
000562  686d              LDR      r5,[r5,#4]
000564  f40561e0          AND      r1,r5,#0x700
;;;1015     tmp = tmp >> 8;
000568  0a09              LSRS     r1,r1,#8
;;;1016     presc = APBAHBPrescTable[tmp];
00056a  4db1              LDR      r5,|L1.2096|
00056c  5c6b              LDRB     r3,[r5,r1]
;;;1017     /* PCLK1 clock frequency */
;;;1018     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
00056e  6845              LDR      r5,[r0,#4]
000570  40dd              LSRS     r5,r5,r3
000572  6085              STR      r5,[r0,#8]
;;;1019     /* Get PCLK2 prescaler */
;;;1020     tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000574  4daa              LDR      r5,|L1.2080|
000576  3d20              SUBS     r5,r5,#0x20
000578  686d              LDR      r5,[r5,#4]
00057a  f4055160          AND      r1,r5,#0x3800
;;;1021     tmp = tmp >> 11;
00057e  0ac9              LSRS     r1,r1,#11
;;;1022     presc = APBAHBPrescTable[tmp];
000580  4dab              LDR      r5,|L1.2096|
000582  5c6b              LDRB     r3,[r5,r1]
;;;1023     /* PCLK2 clock frequency */
;;;1024     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000584  6845              LDR      r5,[r0,#4]
000586  40dd              LSRS     r5,r5,r3
000588  60c5              STR      r5,[r0,#0xc]
;;;1025     /* Get ADCCLK prescaler */
;;;1026     tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
00058a  4da5              LDR      r5,|L1.2080|
00058c  3d20              SUBS     r5,r5,#0x20
00058e  686d              LDR      r5,[r5,#4]
000590  f4054140          AND      r1,r5,#0xc000
;;;1027     tmp = tmp >> 14;
000594  0b89              LSRS     r1,r1,#14
;;;1028     presc = ADCPrescTable[tmp];
000596  4da7              LDR      r5,|L1.2100|
000598  5c6b              LDRB     r3,[r5,r1]
;;;1029     /* ADCCLK clock frequency */
;;;1030     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
00059a  68c5              LDR      r5,[r0,#0xc]
00059c  fbb5f5f3          UDIV     r5,r5,r3
0005a0  6105              STR      r5,[r0,#0x10]
;;;1031   }
0005a2  bd30              POP      {r4,r5,pc}
;;;1032   
                          ENDP

                  RCC_AHBPeriphClockCmd PROC
;;;1063     */
;;;1064   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
0005a4  b570              PUSH     {r4-r6,lr}
;;;1065   {
0005a6  4604              MOV      r4,r0
0005a8  460d              MOV      r5,r1
;;;1066     /* Check the parameters */
;;;1067     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
0005aa  f2405057          MOV      r0,#0x557
0005ae  ea240000          BIC      r0,r4,r0
0005b2  b908              CBNZ     r0,|L1.1464|
0005b4  b104              CBZ      r4,|L1.1464|
0005b6  e005              B        |L1.1476|
                  |L1.1464|
0005b8  f240412b          MOV      r1,#0x42b
0005bc  f2af10b8          ADR      r0,|L1.1032|
0005c0  f7fffffe          BL       assert_failed
                  |L1.1476|
;;;1068     assert_param(IS_FUNCTIONAL_STATE(NewState));
0005c4  b10d              CBZ      r5,|L1.1482|
0005c6  2d01              CMP      r5,#1
0005c8  d100              BNE      |L1.1484|
                  |L1.1482|
0005ca  e005              B        |L1.1496|
                  |L1.1484|
0005cc  f240412c          MOV      r1,#0x42c
0005d0  f2af10cc          ADR      r0,|L1.1032|
0005d4  f7fffffe          BL       assert_failed
                  |L1.1496|
;;;1069   
;;;1070     if (NewState != DISABLE)
0005d8  b13d              CBZ      r5,|L1.1514|
;;;1071     {
;;;1072       RCC->AHBENR |= RCC_AHBPeriph;
0005da  4891              LDR      r0,|L1.2080|
0005dc  3820              SUBS     r0,r0,#0x20
0005de  6940              LDR      r0,[r0,#0x14]
0005e0  4320              ORRS     r0,r0,r4
0005e2  498f              LDR      r1,|L1.2080|
0005e4  3920              SUBS     r1,r1,#0x20
0005e6  6148              STR      r0,[r1,#0x14]
0005e8  e006              B        |L1.1528|
                  |L1.1514|
;;;1073     }
;;;1074     else
;;;1075     {
;;;1076       RCC->AHBENR &= ~RCC_AHBPeriph;
0005ea  488d              LDR      r0,|L1.2080|
0005ec  3820              SUBS     r0,r0,#0x20
0005ee  6940              LDR      r0,[r0,#0x14]
0005f0  43a0              BICS     r0,r0,r4
0005f2  498b              LDR      r1,|L1.2080|
0005f4  3920              SUBS     r1,r1,#0x20
0005f6  6148              STR      r0,[r1,#0x14]
                  |L1.1528|
;;;1077     }
;;;1078   }
0005f8  bd70              POP      {r4-r6,pc}
;;;1079   
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;1094     */
;;;1095   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
0005fa  b570              PUSH     {r4-r6,lr}
;;;1096   {
0005fc  4604              MOV      r4,r0
0005fe  460d              MOV      r5,r1
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
000600  488d              LDR      r0,|L1.2104|
000602  4020              ANDS     r0,r0,r4
000604  b908              CBNZ     r0,|L1.1546|
000606  b104              CBZ      r4,|L1.1546|
000608  e005              B        |L1.1558|
                  |L1.1546|
00060a  f240414a          MOV      r1,#0x44a
00060e  f2af2008          ADR      r0,|L1.1032|
000612  f7fffffe          BL       assert_failed
                  |L1.1558|
;;;1099     assert_param(IS_FUNCTIONAL_STATE(NewState));
000616  b10d              CBZ      r5,|L1.1564|
000618  2d01              CMP      r5,#1
00061a  d100              BNE      |L1.1566|
                  |L1.1564|
00061c  e005              B        |L1.1578|
                  |L1.1566|
00061e  f240414b          MOV      r1,#0x44b
000622  f2af201c          ADR      r0,|L1.1032|
000626  f7fffffe          BL       assert_failed
                  |L1.1578|
;;;1100     if (NewState != DISABLE)
00062a  b13d              CBZ      r5,|L1.1596|
;;;1101     {
;;;1102       RCC->APB2ENR |= RCC_APB2Periph;
00062c  487c              LDR      r0,|L1.2080|
00062e  3820              SUBS     r0,r0,#0x20
000630  6980              LDR      r0,[r0,#0x18]
000632  4320              ORRS     r0,r0,r4
000634  497a              LDR      r1,|L1.2080|
000636  3920              SUBS     r1,r1,#0x20
000638  6188              STR      r0,[r1,#0x18]
00063a  e006              B        |L1.1610|
                  |L1.1596|
;;;1103     }
;;;1104     else
;;;1105     {
;;;1106       RCC->APB2ENR &= ~RCC_APB2Periph;
00063c  4878              LDR      r0,|L1.2080|
00063e  3820              SUBS     r0,r0,#0x20
000640  6980              LDR      r0,[r0,#0x18]
000642  43a0              BICS     r0,r0,r4
000644  4976              LDR      r1,|L1.2080|
000646  3920              SUBS     r1,r1,#0x20
000648  6188              STR      r0,[r1,#0x18]
                  |L1.1610|
;;;1107     }
;;;1108   }
00064a  bd70              POP      {r4-r6,pc}
;;;1109   
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;1125     */
;;;1126   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
00064c  b570              PUSH     {r4-r6,lr}
;;;1127   {
00064e  4604              MOV      r4,r0
000650  460d              MOV      r5,r1
;;;1128     /* Check the parameters */
;;;1129     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
000652  487a              LDR      r0,|L1.2108|
000654  4020              ANDS     r0,r0,r4
000656  b908              CBNZ     r0,|L1.1628|
000658  b104              CBZ      r4,|L1.1628|
00065a  e005              B        |L1.1640|
                  |L1.1628|
00065c  f2404169          MOV      r1,#0x469
000660  f2af205c          ADR      r0,|L1.1032|
000664  f7fffffe          BL       assert_failed
                  |L1.1640|
;;;1130     assert_param(IS_FUNCTIONAL_STATE(NewState));
000668  b10d              CBZ      r5,|L1.1646|
00066a  2d01              CMP      r5,#1
00066c  d100              BNE      |L1.1648|
                  |L1.1646|
00066e  e005              B        |L1.1660|
                  |L1.1648|
000670  f240416a          MOV      r1,#0x46a
000674  f2af2070          ADR      r0,|L1.1032|
000678  f7fffffe          BL       assert_failed
                  |L1.1660|
;;;1131     if (NewState != DISABLE)
00067c  b13d              CBZ      r5,|L1.1678|
;;;1132     {
;;;1133       RCC->APB1ENR |= RCC_APB1Periph;
00067e  4868              LDR      r0,|L1.2080|
000680  3820              SUBS     r0,r0,#0x20
000682  69c0              LDR      r0,[r0,#0x1c]
000684  4320              ORRS     r0,r0,r4
000686  4966              LDR      r1,|L1.2080|
000688  3920              SUBS     r1,r1,#0x20
00068a  61c8              STR      r0,[r1,#0x1c]
00068c  e006              B        |L1.1692|
                  |L1.1678|
;;;1134     }
;;;1135     else
;;;1136     {
;;;1137       RCC->APB1ENR &= ~RCC_APB1Periph;
00068e  4864              LDR      r0,|L1.2080|
000690  3820              SUBS     r0,r0,#0x20
000692  69c0              LDR      r0,[r0,#0x1c]
000694  43a0              BICS     r0,r0,r4
000696  4962              LDR      r1,|L1.2080|
000698  3920              SUBS     r1,r1,#0x20
00069a  61c8              STR      r0,[r1,#0x1c]
                  |L1.1692|
;;;1138     }
;;;1139   }
00069c  bd70              POP      {r4-r6,pc}
;;;1140   
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;1184     */
;;;1185   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
00069e  b570              PUSH     {r4-r6,lr}
;;;1186   {
0006a0  4604              MOV      r4,r0
0006a2  460d              MOV      r5,r1
;;;1187     /* Check the parameters */
;;;1188     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
0006a4  4864              LDR      r0,|L1.2104|
0006a6  4020              ANDS     r0,r0,r4
0006a8  b908              CBNZ     r0,|L1.1710|
0006aa  b104              CBZ      r4,|L1.1710|
0006ac  e005              B        |L1.1722|
                  |L1.1710|
0006ae  f24041a4          MOV      r1,#0x4a4
0006b2  f2af20ac          ADR      r0,|L1.1032|
0006b6  f7fffffe          BL       assert_failed
                  |L1.1722|
;;;1189     assert_param(IS_FUNCTIONAL_STATE(NewState));
0006ba  b10d              CBZ      r5,|L1.1728|
0006bc  2d01              CMP      r5,#1
0006be  d100              BNE      |L1.1730|
                  |L1.1728|
0006c0  e005              B        |L1.1742|
                  |L1.1730|
0006c2  f24041a5          MOV      r1,#0x4a5
0006c6  f2af20c0          ADR      r0,|L1.1032|
0006ca  f7fffffe          BL       assert_failed
                  |L1.1742|
;;;1190     if (NewState != DISABLE)
0006ce  b13d              CBZ      r5,|L1.1760|
;;;1191     {
;;;1192       RCC->APB2RSTR |= RCC_APB2Periph;
0006d0  4853              LDR      r0,|L1.2080|
0006d2  3820              SUBS     r0,r0,#0x20
0006d4  68c0              LDR      r0,[r0,#0xc]
0006d6  4320              ORRS     r0,r0,r4
0006d8  4951              LDR      r1,|L1.2080|
0006da  3920              SUBS     r1,r1,#0x20
0006dc  60c8              STR      r0,[r1,#0xc]
0006de  e006              B        |L1.1774|
                  |L1.1760|
;;;1193     }
;;;1194     else
;;;1195     {
;;;1196       RCC->APB2RSTR &= ~RCC_APB2Periph;
0006e0  484f              LDR      r0,|L1.2080|
0006e2  3820              SUBS     r0,r0,#0x20
0006e4  68c0              LDR      r0,[r0,#0xc]
0006e6  43a0              BICS     r0,r0,r4
0006e8  494d              LDR      r1,|L1.2080|
0006ea  3920              SUBS     r1,r1,#0x20
0006ec  60c8              STR      r0,[r1,#0xc]
                  |L1.1774|
;;;1197     }
;;;1198   }
0006ee  bd70              POP      {r4-r6,pc}
;;;1199   
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;1215     */
;;;1216   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
0006f0  b570              PUSH     {r4-r6,lr}
;;;1217   {
0006f2  4604              MOV      r4,r0
0006f4  460d              MOV      r5,r1
;;;1218     /* Check the parameters */
;;;1219     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
0006f6  4851              LDR      r0,|L1.2108|
0006f8  4020              ANDS     r0,r0,r4
0006fa  b908              CBNZ     r0,|L1.1792|
0006fc  b104              CBZ      r4,|L1.1792|
0006fe  e005              B        |L1.1804|
                  |L1.1792|
000700  f24041c3          MOV      r1,#0x4c3
000704  f2af3000          ADR      r0,|L1.1032|
000708  f7fffffe          BL       assert_failed
                  |L1.1804|
;;;1220     assert_param(IS_FUNCTIONAL_STATE(NewState));
00070c  b10d              CBZ      r5,|L1.1810|
00070e  2d01              CMP      r5,#1
000710  d100              BNE      |L1.1812|
                  |L1.1810|
000712  e005              B        |L1.1824|
                  |L1.1812|
000714  f24041c4          MOV      r1,#0x4c4
000718  f2af3014          ADR      r0,|L1.1032|
00071c  f7fffffe          BL       assert_failed
                  |L1.1824|
;;;1221     if (NewState != DISABLE)
000720  b13d              CBZ      r5,|L1.1842|
;;;1222     {
;;;1223       RCC->APB1RSTR |= RCC_APB1Periph;
000722  483f              LDR      r0,|L1.2080|
000724  3820              SUBS     r0,r0,#0x20
000726  6900              LDR      r0,[r0,#0x10]
000728  4320              ORRS     r0,r0,r4
00072a  493d              LDR      r1,|L1.2080|
00072c  3920              SUBS     r1,r1,#0x20
00072e  6108              STR      r0,[r1,#0x10]
000730  e006              B        |L1.1856|
                  |L1.1842|
;;;1224     }
;;;1225     else
;;;1226     {
;;;1227       RCC->APB1RSTR &= ~RCC_APB1Periph;
000732  483b              LDR      r0,|L1.2080|
000734  3820              SUBS     r0,r0,#0x20
000736  6900              LDR      r0,[r0,#0x10]
000738  43a0              BICS     r0,r0,r4
00073a  4939              LDR      r1,|L1.2080|
00073c  3920              SUBS     r1,r1,#0x20
00073e  6108              STR      r0,[r1,#0x10]
                  |L1.1856|
;;;1228     }
;;;1229   }
000740  bd70              POP      {r4-r6,pc}
;;;1230   
                          ENDP

                  RCC_BackupResetCmd PROC
;;;1236     */
;;;1237   void RCC_BackupResetCmd(FunctionalState NewState)
000742  b510              PUSH     {r4,lr}
;;;1238   {
000744  4604              MOV      r4,r0
;;;1239     /* Check the parameters */
;;;1240     assert_param(IS_FUNCTIONAL_STATE(NewState));
000746  b10c              CBZ      r4,|L1.1868|
000748  2c01              CMP      r4,#1
00074a  d100              BNE      |L1.1870|
                  |L1.1868|
00074c  e005              B        |L1.1882|
                  |L1.1870|
00074e  f44f619b          MOV      r1,#0x4d8
000752  f2af304c          ADR      r0,|L1.1032|
000756  f7fffffe          BL       assert_failed
                  |L1.1882|
;;;1241     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
00075a  4832              LDR      r0,|L1.2084|
00075c  3840              SUBS     r0,r0,#0x40
00075e  6004              STR      r4,[r0,#0]
;;;1242   }
000760  bd10              POP      {r4,pc}
;;;1243   
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;1249     */
;;;1250   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000762  b510              PUSH     {r4,lr}
;;;1251   {
000764  4604              MOV      r4,r0
;;;1252     /* Check the parameters */
;;;1253     assert_param(IS_FUNCTIONAL_STATE(NewState));
000766  b10c              CBZ      r4,|L1.1900|
000768  2c01              CMP      r4,#1
00076a  d100              BNE      |L1.1902|
                  |L1.1900|
00076c  e005              B        |L1.1914|
                  |L1.1902|
00076e  f24041e5          MOV      r1,#0x4e5
000772  f2af306c          ADR      r0,|L1.1032|
000776  f7fffffe          BL       assert_failed
                  |L1.1914|
;;;1254     *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
00077a  4831              LDR      r0,|L1.2112|
00077c  64c4              STR      r4,[r0,#0x4c]
;;;1255   }
00077e  bd10              POP      {r4,pc}
;;;1256   
                          ENDP

                  RCC_MCOConfig PROC
;;;1281     */
;;;1282   void RCC_MCOConfig(uint8_t RCC_MCO)
000780  b510              PUSH     {r4,lr}
;;;1283   {
000782  4604              MOV      r4,r0
;;;1284     /* Check the parameters */
;;;1285     assert_param(IS_RCC_MCO(RCC_MCO));
000784  b13c              CBZ      r4,|L1.1942|
000786  2c05              CMP      r4,#5
000788  d005              BEQ      |L1.1942|
00078a  2c04              CMP      r4,#4
00078c  d003              BEQ      |L1.1942|
00078e  2c06              CMP      r4,#6
000790  d001              BEQ      |L1.1942|
000792  2c07              CMP      r4,#7
000794  d100              BNE      |L1.1944|
                  |L1.1942|
000796  e005              B        |L1.1956|
                  |L1.1944|
000798  f2405105          MOV      r1,#0x505
00079c  f2af3098          ADR      r0,|L1.1032|
0007a0  f7fffffe          BL       assert_failed
                  |L1.1956|
;;;1286   
;;;1287     /* Perform Byte access to MCO bits to select the MCO source */
;;;1288     *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
0007a4  481e              LDR      r0,|L1.2080|
0007a6  3820              SUBS     r0,r0,#0x20
0007a8  71c4              STRB     r4,[r0,#7]
;;;1289   }
0007aa  bd10              POP      {r4,pc}
;;;1290   
                          ENDP

                  RCC_ClearFlag PROC
;;;1370     */
;;;1371   void RCC_ClearFlag(void)
0007ac  481c              LDR      r0,|L1.2080|
;;;1372   {
;;;1373     /* Set RMVF bit to clear the reset flags */
;;;1374     RCC->CSR |= CSR_RMVF_Set;
0007ae  3820              SUBS     r0,r0,#0x20
0007b0  6a40              LDR      r0,[r0,#0x24]
0007b2  f0407080          ORR      r0,r0,#0x1000000
0007b6  491a              LDR      r1,|L1.2080|
0007b8  3920              SUBS     r1,r1,#0x20
0007ba  6248              STR      r0,[r1,#0x24]
;;;1375   }
0007bc  4770              BX       lr
;;;1376   
                          ENDP

                  RCC_GetITStatus PROC
;;;1401     */
;;;1402   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
0007be  b570              PUSH     {r4-r6,lr}
;;;1403   {
0007c0  4604              MOV      r4,r0
;;;1404     ITStatus bitstatus = RESET;
0007c2  2500              MOVS     r5,#0
;;;1405     /* Check the parameters */
;;;1406     assert_param(IS_RCC_GET_IT(RCC_IT));
0007c4  2c01              CMP      r4,#1
0007c6  d009              BEQ      |L1.2012|
0007c8  2c02              CMP      r4,#2
0007ca  d007              BEQ      |L1.2012|
0007cc  2c04              CMP      r4,#4
0007ce  d005              BEQ      |L1.2012|
0007d0  2c08              CMP      r4,#8
0007d2  d003              BEQ      |L1.2012|
0007d4  2c10              CMP      r4,#0x10
0007d6  d001              BEQ      |L1.2012|
0007d8  2c80              CMP      r4,#0x80
0007da  d100              BNE      |L1.2014|
                  |L1.2012|
0007dc  e005              B        |L1.2026|
                  |L1.2014|
0007de  f240517e          MOV      r1,#0x57e
0007e2  f2af30dc          ADR      r0,|L1.1032|
0007e6  f7fffffe          BL       assert_failed
                  |L1.2026|
;;;1407   
;;;1408     /* Check the status of the specified RCC interrupt */
;;;1409     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
0007ea  480d              LDR      r0,|L1.2080|
0007ec  3820              SUBS     r0,r0,#0x20
0007ee  6880              LDR      r0,[r0,#8]
0007f0  4020              ANDS     r0,r0,r4
0007f2  b108              CBZ      r0,|L1.2040|
;;;1410     {
;;;1411       bitstatus = SET;
0007f4  2501              MOVS     r5,#1
0007f6  e000              B        |L1.2042|
                  |L1.2040|
;;;1412     }
;;;1413     else
;;;1414     {
;;;1415       bitstatus = RESET;
0007f8  2500              MOVS     r5,#0
                  |L1.2042|
;;;1416     }
;;;1417   
;;;1418     /* Return the RCC_IT status */
;;;1419     return  bitstatus;
0007fa  4628              MOV      r0,r5
;;;1420   }
0007fc  bd70              POP      {r4-r6,pc}
;;;1421   
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1447     */
;;;1448   void RCC_ClearITPendingBit(uint8_t RCC_IT)
0007fe  b510              PUSH     {r4,lr}
;;;1449   {
000800  4604              MOV      r4,r0
;;;1450     /* Check the parameters */
;;;1451     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
000802  f0040060          AND      r0,r4,#0x60
000806  b908              CBNZ     r0,|L1.2060|
000808  b104              CBZ      r4,|L1.2060|
00080a  e005              B        |L1.2072|
                  |L1.2060|
00080c  f24051ab          MOV      r1,#0x5ab
000810  f2af400c          ADR      r0,|L1.1032|
000814  f7fffffe          BL       assert_failed
                  |L1.2072|
;;;1452   
;;;1453     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1454        pending bits */
;;;1455     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000818  4801              LDR      r0,|L1.2080|
00081a  3820              SUBS     r0,r0,#0x20
00081c  7284              STRB     r4,[r0,#0xa]
;;;1456   }
00081e  bd10              POP      {r4,pc}
;;;1457   
                          ENDP

                  |L1.2080|
                          DCD      0x40021020
                  |L1.2084|
                          DCD      0x42420480
                  |L1.2088|
                          DCD      0x007a1200
                  |L1.2092|
                          DCD      0x003d0900
                  |L1.2096|
                          DCD      APBAHBPrescTable
                  |L1.2100|
                          DCD      ADCPrescTable
                  |L1.2104|
                          DCD      0xffc00002
                  |L1.2108|
                          DCD      0x81013600
                  |L1.2112|
                          DCD      0x42420000

                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000010  02040608          DCB      0x02,0x04,0x06,0x08

;*** Start embedded assembler ***

#line 1 "Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REV16|
#line 129 "..\\..\\components\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_rcc_c_49e27980____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REVSH|
#line 144
|__asm___15_stm32f10x_rcc_c_49e27980____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
