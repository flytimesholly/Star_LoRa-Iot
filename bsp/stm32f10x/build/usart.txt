; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\build\usart.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -Iapplications -I. -Idrivers -ILibraries\STM32F10x_StdPeriph_Driver\inc -ILibraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\components\CMSIS\Include -I..\..\include -I..\..\libcpu\arm\cortex-m3 -I..\..\libcpu\arm\common -I..\..\components\drivers\include -I..\..\components\drivers\include -I..\..\components\drivers\include -I..\..\components\drivers\include -I..\..\components\drivers\spi -I..\..\components\drivers\include -I..\..\components\drivers\include -I..\..\components\finsh -I..\..\components\libc\compilers\armlibc -I..\..\components\libc\compilers\common -IE:\00_snake.xiao\RT-Thread\rt-thread\bsp\stm32f10x\RTE\_rtthread-stm32 -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DSTM32F10X_HD -DSTM32F10X_HD -DRT_USING_ARM_LIBC -DUSE_STDPERIPH_DRIVER --omf_browse=.\build\usart.crf drivers\usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  stm32_configure PROC
;;;68     
;;;69     static rt_err_t stm32_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
000000  b57f              PUSH     {r0-r6,lr}
;;;70     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;71         struct stm32_uart* uart;
;;;72         USART_InitTypeDef USART_InitStructure;
;;;73     
;;;74         RT_ASSERT(serial != RT_NULL);
000006  b925              CBNZ     r5,|L1.18|
000008  224a              MOVS     r2,#0x4a
00000a  49f7              LDR      r1,|L1.1000|
00000c  a0f7              ADR      r0,|L1.1004|
00000e  f7fffffe          BL       rt_assert_handler
                  |L1.18|
;;;75         RT_ASSERT(cfg != RT_NULL);
000012  b924              CBNZ     r4,|L1.30|
000014  224b              MOVS     r2,#0x4b
000016  49f4              LDR      r1,|L1.1000|
000018  a0f9              ADR      r0,|L1.1024|
00001a  f7fffffe          BL       rt_assert_handler
                  |L1.30|
;;;76     
;;;77         uart = (struct stm32_uart *)serial->parent.user_data;
00001e  6bee              LDR      r6,[r5,#0x3c]
;;;78     
;;;79         USART_InitStructure.USART_BaudRate = cfg->baud_rate;
000020  6820              LDR      r0,[r4,#0]
000022  9000              STR      r0,[sp,#0]
;;;80     
;;;81         if (cfg->data_bits == DATA_BITS_8){
000024  7920              LDRB     r0,[r4,#4]
000026  f000000f          AND      r0,r0,#0xf
00002a  2808              CMP      r0,#8
00002c  d103              BNE      |L1.54|
;;;82             USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00002e  2000              MOVS     r0,#0
000030  f8ad0004          STRH     r0,[sp,#4]
000034  e008              B        |L1.72|
                  |L1.54|
;;;83         } else if (cfg->data_bits == DATA_BITS_9) {
000036  7920              LDRB     r0,[r4,#4]
000038  f000000f          AND      r0,r0,#0xf
00003c  2809              CMP      r0,#9
00003e  d103              BNE      |L1.72|
;;;84             USART_InitStructure.USART_WordLength = USART_WordLength_9b;
000040  f44f5080          MOV      r0,#0x1000
000044  f8ad0004          STRH     r0,[sp,#4]
                  |L1.72|
;;;85         }
;;;86     
;;;87         if (cfg->stop_bits == STOP_BITS_1){
000048  7920              LDRB     r0,[r4,#4]
00004a  f3c01001          UBFX     r0,r0,#4,#2
00004e  b918              CBNZ     r0,|L1.88|
;;;88             USART_InitStructure.USART_StopBits = USART_StopBits_1;
000050  2000              MOVS     r0,#0
000052  f8ad0006          STRH     r0,[sp,#6]
000056  e007              B        |L1.104|
                  |L1.88|
;;;89         } else if (cfg->stop_bits == STOP_BITS_2){
000058  7920              LDRB     r0,[r4,#4]
00005a  f3c01001          UBFX     r0,r0,#4,#2
00005e  2801              CMP      r0,#1
000060  d102              BNE      |L1.104|
;;;90             USART_InitStructure.USART_StopBits = USART_StopBits_2;
000062  0340              LSLS     r0,r0,#13
000064  f8ad0006          STRH     r0,[sp,#6]
                  |L1.104|
;;;91         }
;;;92     
;;;93         if (cfg->parity == PARITY_NONE){
000068  7920              LDRB     r0,[r4,#4]
00006a  f3c01081          UBFX     r0,r0,#6,#2
00006e  b918              CBNZ     r0,|L1.120|
;;;94             USART_InitStructure.USART_Parity = USART_Parity_No;
000070  2000              MOVS     r0,#0
000072  f8ad0008          STRH     r0,[sp,#8]
000076  e011              B        |L1.156|
                  |L1.120|
;;;95         } else if (cfg->parity == PARITY_ODD) {
000078  7920              LDRB     r0,[r4,#4]
00007a  f3c01081          UBFX     r0,r0,#6,#2
00007e  2801              CMP      r0,#1
000080  d104              BNE      |L1.140|
;;;96             USART_InitStructure.USART_Parity = USART_Parity_Odd;
000082  f44f60c0          MOV      r0,#0x600
000086  f8ad0008          STRH     r0,[sp,#8]
00008a  e007              B        |L1.156|
                  |L1.140|
;;;97         } else if (cfg->parity == PARITY_EVEN) {
00008c  7920              LDRB     r0,[r4,#4]
00008e  f3c01081          UBFX     r0,r0,#6,#2
000092  2802              CMP      r0,#2
000094  d102              BNE      |L1.156|
;;;98             USART_InitStructure.USART_Parity = USART_Parity_Even;
000096  0240              LSLS     r0,r0,#9
000098  f8ad0008          STRH     r0,[sp,#8]
                  |L1.156|
;;;99         }
;;;100    
;;;101        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00009c  2000              MOVS     r0,#0
00009e  f8ad000c          STRH     r0,[sp,#0xc]
;;;102        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0000a2  200c              MOVS     r0,#0xc
0000a4  f8ad000a          STRH     r0,[sp,#0xa]
;;;103        USART_Init(uart->uart_device, &USART_InitStructure);
0000a8  4669              MOV      r1,sp
0000aa  6830              LDR      r0,[r6,#0]
0000ac  f7fffffe          BL       USART_Init
;;;104    
;;;105        /* Enable USART */
;;;106        USART_Cmd(uart->uart_device, ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  6830              LDR      r0,[r6,#0]
0000b4  f7fffffe          BL       USART_Cmd
;;;107    
;;;108        return RT_EOK;
0000b8  2000              MOVS     r0,#0
;;;109    }
0000ba  b004              ADD      sp,sp,#0x10
0000bc  bd70              POP      {r4-r6,pc}
;;;110    
                          ENDP

                  DMA_Configuration PROC
;;;553    #ifdef RT_SERIAL_USING_DMA
;;;554    static void DMA_Configuration(struct rt_serial_device *serial) {
0000be  b570              PUSH     {r4-r6,lr}
0000c0  b08c              SUB      sp,sp,#0x30
0000c2  4605              MOV      r5,r0
;;;555        struct stm32_uart *uart = (struct stm32_uart *) serial->parent.user_data;
0000c4  6bec              LDR      r4,[r5,#0x3c]
;;;556        struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *)serial->serial_rx;
0000c6  6cee              LDR      r6,[r5,#0x4c]
;;;557        DMA_InitTypeDef DMA_InitStructure;
;;;558        NVIC_InitTypeDef NVIC_InitStructure;
;;;559    
;;;560        uart->dma.setting_recv_len = serial->config.bufsz;
0000c8  6ca8              LDR      r0,[r5,#0x48]
0000ca  f3c0218f          UBFX     r1,r0,#10,#16
0000ce  6161              STR      r1,[r4,#0x14]
;;;561        
;;;562        /* enable transmit idle interrupt */
;;;563        USART_ITConfig(uart->uart_device, USART_IT_IDLE , ENABLE);
0000d0  2201              MOVS     r2,#1
0000d2  f2404124          MOV      r1,#0x424
0000d6  6820              LDR      r0,[r4,#0]
0000d8  f7fffffe          BL       USART_ITConfig
;;;564    
;;;565        /* DMA clock enable */
;;;566        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  4608              MOV      r0,r1
0000e0  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;567        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);
0000e4  2101              MOVS     r1,#1
0000e6  2002              MOVS     r0,#2
0000e8  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;568    
;;;569        /* rx dma config */
;;;570        DMA_DeInit(uart->dma.rx_ch);
0000ec  68a0              LDR      r0,[r4,#8]
0000ee  f7fffffe          BL       DMA_DeInit
;;;571        DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(uart->uart_device->DR);
0000f2  6820              LDR      r0,[r4,#0]
0000f4  1d00              ADDS     r0,r0,#4
0000f6  9001              STR      r0,[sp,#4]
;;;572        DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) rx_fifo->buffer;
0000f8  6830              LDR      r0,[r6,#0]
0000fa  9002              STR      r0,[sp,#8]
;;;573        DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
0000fc  2000              MOVS     r0,#0
0000fe  9003              STR      r0,[sp,#0xc]
;;;574        DMA_InitStructure.DMA_BufferSize = serial->config.bufsz;
000100  6ca8              LDR      r0,[r5,#0x48]
000102  f3c0208f          UBFX     r0,r0,#10,#16
000106  9004              STR      r0,[sp,#0x10]
;;;575        DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000108  2000              MOVS     r0,#0
00010a  9005              STR      r0,[sp,#0x14]
;;;576        DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
00010c  2080              MOVS     r0,#0x80
00010e  9006              STR      r0,[sp,#0x18]
;;;577        DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
000110  2000              MOVS     r0,#0
000112  9007              STR      r0,[sp,#0x1c]
;;;578        DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
000114  9008              STR      r0,[sp,#0x20]
;;;579        DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
000116  2020              MOVS     r0,#0x20
000118  9009              STR      r0,[sp,#0x24]
;;;580        DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00011a  0200              LSLS     r0,r0,#8
00011c  900a              STR      r0,[sp,#0x28]
;;;581        DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
00011e  2000              MOVS     r0,#0
000120  900b              STR      r0,[sp,#0x2c]
;;;582        DMA_Init(uart->dma.rx_ch, &DMA_InitStructure);
000122  a901              ADD      r1,sp,#4
000124  68a0              LDR      r0,[r4,#8]
000126  f7fffffe          BL       DMA_Init
;;;583        DMA_ClearFlag(uart->dma.rx_gl_flag);
00012a  68e0              LDR      r0,[r4,#0xc]
00012c  f7fffffe          BL       DMA_ClearFlag
;;;584        DMA_ITConfig(uart->dma.rx_ch, DMA_IT_TC, ENABLE);
000130  2201              MOVS     r2,#1
000132  2102              MOVS     r1,#2
000134  68a0              LDR      r0,[r4,#8]
000136  f7fffffe          BL       DMA_ITConfig
;;;585        USART_DMACmd(uart->uart_device, USART_DMAReq_Rx, ENABLE);
00013a  2201              MOVS     r2,#1
00013c  2140              MOVS     r1,#0x40
00013e  6820              LDR      r0,[r4,#0]
000140  f7fffffe          BL       USART_DMACmd
;;;586        DMA_Cmd(uart->dma.rx_ch, ENABLE);
000144  2101              MOVS     r1,#1
000146  68a0              LDR      r0,[r4,#8]
000148  f7fffffe          BL       DMA_Cmd
;;;587    
;;;588        /* rx dma interrupt config */
;;;589        NVIC_InitStructure.NVIC_IRQChannel = uart->dma.rx_irq_ch;
00014c  7c20              LDRB     r0,[r4,#0x10]
00014e  f88d0000          STRB     r0,[sp,#0]
;;;590        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000152  2000              MOVS     r0,#0
000154  f88d0001          STRB     r0,[sp,#1]
;;;591        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000158  f88d0002          STRB     r0,[sp,#2]
;;;592        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00015c  2001              MOVS     r0,#1
00015e  f88d0003          STRB     r0,[sp,#3]
;;;593        NVIC_Init(&NVIC_InitStructure);
000162  4668              MOV      r0,sp
000164  f7fffffe          BL       NVIC_Init
;;;594    }
000168  b00c              ADD      sp,sp,#0x30
00016a  bd70              POP      {r4-r6,pc}
;;;595    #endif /* RT_SERIAL_USING_DMA */   
                          ENDP

                  stm32_control PROC
;;;110    
;;;111    static rt_err_t stm32_control(struct rt_serial_device *serial, int cmd, void *arg)
00016c  e92d41f0          PUSH     {r4-r8,lr}
;;;112    {
000170  4605              MOV      r5,r0
000172  460e              MOV      r6,r1
000174  4617              MOV      r7,r2
;;;113        struct stm32_uart* uart;
;;;114    
;;;115        RT_ASSERT(serial != RT_NULL);
000176  b925              CBNZ     r5,|L1.386|
000178  2273              MOVS     r2,#0x73
00017a  49a5              LDR      r1,|L1.1040|
00017c  a09b              ADR      r0,|L1.1004|
00017e  f7fffffe          BL       rt_assert_handler
                  |L1.386|
;;;116        uart = (struct stm32_uart *)serial->parent.user_data;
000182  6bec              LDR      r4,[r5,#0x3c]
;;;117    
;;;118        switch (cmd)
000184  2e03              CMP      r6,#3
000186  d029              BEQ      |L1.476|
000188  2e10              CMP      r6,#0x10
00018a  d013              BEQ      |L1.436|
00018c  2e11              CMP      r6,#0x11
00018e  d12c              BNE      |L1.490|
;;;119        {
;;;120            /* disable interrupt */
;;;121        case RT_DEVICE_CTRL_CLR_INT:
;;;122            /* disable rx irq */
;;;123            UART_DISABLE_IRQ(uart->irq);
000190  f9940004          LDRSB    r0,[r4,#4]
000194  f000021f          AND      r2,r0,#0x1f
000198  2101              MOVS     r1,#1
00019a  4091              LSLS     r1,r1,r2
00019c  4a9d              LDR      r2,|L1.1044|
00019e  0943              LSRS     r3,r0,#5
0001a0  f8421023          STR      r1,[r2,r3,LSL #2]
0001a4  bf00              NOP      
;;;124            /* disable interrupt */
;;;125            USART_ITConfig(uart->uart_device, USART_IT_RXNE, DISABLE);
0001a6  2200              MOVS     r2,#0
0001a8  f2405125          MOV      r1,#0x525
0001ac  6820              LDR      r0,[r4,#0]
0001ae  f7fffffe          BL       USART_ITConfig
;;;126            break;
0001b2  e01a              B        |L1.490|
                  |L1.436|
;;;127            /* enable interrupt */
;;;128        case RT_DEVICE_CTRL_SET_INT:
;;;129            /* enable rx irq */
;;;130            UART_ENABLE_IRQ(uart->irq);
0001b4  f9940004          LDRSB    r0,[r4,#4]
0001b8  f000021f          AND      r2,r0,#0x1f
0001bc  2101              MOVS     r1,#1
0001be  4091              LSLS     r1,r1,r2
0001c0  0942              LSRS     r2,r0,#5
0001c2  0092              LSLS     r2,r2,#2
0001c4  f10222e0          ADD      r2,r2,#0xe000e000
0001c8  f8c21100          STR      r1,[r2,#0x100]
0001cc  bf00              NOP      
;;;131            /* enable interrupt */
;;;132            USART_ITConfig(uart->uart_device, USART_IT_RXNE, ENABLE);
0001ce  2201              MOVS     r2,#1
0001d0  f2405125          MOV      r1,#0x525
0001d4  6820              LDR      r0,[r4,#0]
0001d6  f7fffffe          BL       USART_ITConfig
;;;133            break;
0001da  e006              B        |L1.490|
                  |L1.476|
;;;134    #ifdef RT_SERIAL_USING_DMA
;;;135            /* USART config */
;;;136        case RT_DEVICE_CTRL_CONFIG :
;;;137            if ((rt_uint32_t)(arg) == RT_DEVICE_FLAG_DMA_RX) {
0001dc  f5b77f00          CMP      r7,#0x200
0001e0  d102              BNE      |L1.488|
;;;138                DMA_Configuration(serial);
0001e2  4628              MOV      r0,r5
0001e4  f7fffffe          BL       DMA_Configuration
                  |L1.488|
;;;139            }
;;;140            break;
0001e8  bf00              NOP      
                  |L1.490|
0001ea  bf00              NOP                            ;126
;;;141    #endif /* RT_SERIAL_USING_DMA */    
;;;142        }
;;;143        return RT_EOK;
0001ec  2000              MOVS     r0,#0
;;;144    }
0001ee  e8bd81f0          POP      {r4-r8,pc}
;;;145    
                          ENDP

                  stm32_putc PROC
;;;146    static int stm32_putc(struct rt_serial_device *serial, char c)
0001f2  b570              PUSH     {r4-r6,lr}
;;;147    {
0001f4  4605              MOV      r5,r0
0001f6  460e              MOV      r6,r1
;;;148        struct stm32_uart* uart;
;;;149    
;;;150        RT_ASSERT(serial != RT_NULL);
0001f8  b925              CBNZ     r5,|L1.516|
0001fa  2296              MOVS     r2,#0x96
0001fc  4986              LDR      r1,|L1.1048|
0001fe  a07b              ADR      r0,|L1.1004|
000200  f7fffffe          BL       rt_assert_handler
                  |L1.516|
;;;151        uart = (struct stm32_uart *)serial->parent.user_data;
000204  6bec              LDR      r4,[r5,#0x3c]
;;;152    
;;;153        if (serial->parent.open_flag & RT_DEVICE_FLAG_INT_TX)
000206  8b28              LDRH     r0,[r5,#0x18]
000208  f4006080          AND      r0,r0,#0x400
00020c  b1b0              CBZ      r0,|L1.572|
;;;154        {
;;;155            if (!(uart->uart_device->SR & USART_FLAG_TXE))
00020e  6820              LDR      r0,[r4,#0]
000210  8800              LDRH     r0,[r0,#0]
000212  f0000080          AND      r0,r0,#0x80
000216  b940              CBNZ     r0,|L1.554|
;;;156            {
;;;157                USART_ITConfig(uart->uart_device, USART_IT_TC, ENABLE);
000218  2201              MOVS     r2,#1
00021a  f2406126          MOV      r1,#0x626
00021e  6820              LDR      r0,[r4,#0]
000220  f7fffffe          BL       USART_ITConfig
;;;158                return -1;
000224  f04f30ff          MOV      r0,#0xffffffff
                  |L1.552|
;;;159            }
;;;160            uart->uart_device->DR = c;
;;;161            USART_ITConfig(uart->uart_device, USART_IT_TC, ENABLE);
;;;162        }
;;;163        else
;;;164        {
;;;165            USART_ClearFlag(uart->uart_device,USART_FLAG_TC);
;;;166            uart->uart_device->DR = c;
;;;167            while (!(uart->uart_device->SR & USART_FLAG_TC));
;;;168        }
;;;169    
;;;170        return 1;
;;;171    }
000228  bd70              POP      {r4-r6,pc}
                  |L1.554|
00022a  6820              LDR      r0,[r4,#0]            ;160
00022c  8086              STRH     r6,[r0,#4]            ;160
00022e  2201              MOVS     r2,#1                 ;161
000230  f2406126          MOV      r1,#0x626             ;161
000234  6820              LDR      r0,[r4,#0]            ;161
000236  f7fffffe          BL       USART_ITConfig
00023a  e00c              B        |L1.598|
                  |L1.572|
00023c  2140              MOVS     r1,#0x40              ;165
00023e  6820              LDR      r0,[r4,#0]            ;165
000240  f7fffffe          BL       USART_ClearFlag
000244  6820              LDR      r0,[r4,#0]            ;166
000246  8086              STRH     r6,[r0,#4]            ;166
000248  bf00              NOP                            ;167
                  |L1.586|
00024a  6820              LDR      r0,[r4,#0]            ;167
00024c  8800              LDRH     r0,[r0,#0]            ;167
00024e  f0000040          AND      r0,r0,#0x40           ;167
000252  2800              CMP      r0,#0                 ;167
000254  d0f9              BEQ      |L1.586|
                  |L1.598|
000256  2001              MOVS     r0,#1                 ;170
000258  e7e6              B        |L1.552|
;;;172    
                          ENDP

                  stm32_getc PROC
;;;173    static int stm32_getc(struct rt_serial_device *serial)
00025a  b570              PUSH     {r4-r6,lr}
;;;174    {
00025c  4604              MOV      r4,r0
;;;175        int ch;
;;;176        struct stm32_uart* uart;
;;;177    
;;;178        RT_ASSERT(serial != RT_NULL);
00025e  b924              CBNZ     r4,|L1.618|
000260  22b2              MOVS     r2,#0xb2
000262  496e              LDR      r1,|L1.1052|
000264  a061              ADR      r0,|L1.1004|
000266  f7fffffe          BL       rt_assert_handler
                  |L1.618|
;;;179        uart = (struct stm32_uart *)serial->parent.user_data;
00026a  6be5              LDR      r5,[r4,#0x3c]
;;;180    
;;;181        ch = -1;
00026c  f04f36ff          MOV      r6,#0xffffffff
;;;182        if (uart->uart_device->SR & USART_FLAG_RXNE)
000270  6828              LDR      r0,[r5,#0]
000272  8800              LDRH     r0,[r0,#0]
000274  f0000020          AND      r0,r0,#0x20
000278  b110              CBZ      r0,|L1.640|
;;;183        {
;;;184            ch = uart->uart_device->DR & 0xff;
00027a  6828              LDR      r0,[r5,#0]
00027c  8880              LDRH     r0,[r0,#4]
00027e  b2c6              UXTB     r6,r0
                  |L1.640|
;;;185        }
;;;186    
;;;187        return ch;
000280  4630              MOV      r0,r6
;;;188    }
000282  bd70              POP      {r4-r6,pc}
;;;189    
                          ENDP

                  dma_uart_rx_idle_isr PROC
;;;195     */
;;;196    static void dma_uart_rx_idle_isr(struct rt_serial_device *serial) {
000284  e92d41f0          PUSH     {r4-r8,lr}
000288  4605              MOV      r5,r0
;;;197        struct stm32_uart *uart = (struct stm32_uart *) serial->parent.user_data;
00028a  6bec              LDR      r4,[r5,#0x3c]
;;;198        rt_size_t recv_total_index, recv_len;
;;;199        rt_base_t level;
;;;200    
;;;201        /* disable interrupt */
;;;202        level = rt_hw_interrupt_disable();
00028c  f7fffffe          BL       rt_hw_interrupt_disable
000290  4680              MOV      r8,r0
;;;203    
;;;204        recv_total_index = uart->dma.setting_recv_len - DMA_GetCurrDataCounter(uart->dma.rx_ch);
000292  68a0              LDR      r0,[r4,#8]
000294  f7fffffe          BL       DMA_GetCurrDataCounter
000298  6961              LDR      r1,[r4,#0x14]
00029a  1a0e              SUBS     r6,r1,r0
;;;205        recv_len = recv_total_index - uart->dma.last_recv_index;
00029c  69a0              LDR      r0,[r4,#0x18]
00029e  1a37              SUBS     r7,r6,r0
;;;206        uart->dma.last_recv_index = recv_total_index;
0002a0  61a6              STR      r6,[r4,#0x18]
;;;207        /* enable interrupt */
;;;208        rt_hw_interrupt_enable(level);
0002a2  4640              MOV      r0,r8
0002a4  f7fffffe          BL       rt_hw_interrupt_enable
;;;209    
;;;210        if (recv_len) rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_DMADONE | (recv_len << 8));
0002a8  b12f              CBZ      r7,|L1.694|
0002aa  2003              MOVS     r0,#3
0002ac  ea402107          ORR      r1,r0,r7,LSL #8
0002b0  4628              MOV      r0,r5
0002b2  f7fffffe          BL       rt_hw_serial_isr
                  |L1.694|
;;;211    
;;;212        /* read a data for clear receive idle interrupt flag */
;;;213        USART_ReceiveData(uart->uart_device);
0002b6  6820              LDR      r0,[r4,#0]
0002b8  f7fffffe          BL       USART_ReceiveData
;;;214        DMA_ClearFlag(uart->dma.rx_gl_flag);
0002bc  68e0              LDR      r0,[r4,#0xc]
0002be  f7fffffe          BL       DMA_ClearFlag
;;;215    }
0002c2  e8bd81f0          POP      {r4-r8,pc}
;;;216    
                          ENDP

                  dma_rx_done_isr PROC
;;;221     */
;;;222    static void dma_rx_done_isr(struct rt_serial_device *serial) {
0002c6  e92d41f0          PUSH     {r4-r8,lr}
0002ca  4605              MOV      r5,r0
;;;223        struct stm32_uart *uart = (struct stm32_uart *) serial->parent.user_data;
0002cc  6bec              LDR      r4,[r5,#0x3c]
;;;224        rt_size_t recv_len;
;;;225        rt_base_t level;
;;;226    
;;;227        /* disable interrupt */
;;;228        level = rt_hw_interrupt_disable();
0002ce  f7fffffe          BL       rt_hw_interrupt_disable
0002d2  4607              MOV      r7,r0
;;;229    
;;;230        recv_len = uart->dma.setting_recv_len - uart->dma.last_recv_index;
0002d4  e9d41005          LDRD     r1,r0,[r4,#0x14]
0002d8  1a0e              SUBS     r6,r1,r0
;;;231        /* reset last recv index */
;;;232        uart->dma.last_recv_index = 0;
0002da  2100              MOVS     r1,#0
0002dc  61a1              STR      r1,[r4,#0x18]
;;;233        /* enable interrupt */
;;;234        rt_hw_interrupt_enable(level);
0002de  4638              MOV      r0,r7
0002e0  f7fffffe          BL       rt_hw_interrupt_enable
;;;235    
;;;236        if (recv_len) rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_DMADONE | (recv_len << 8));
0002e4  b12e              CBZ      r6,|L1.754|
0002e6  2003              MOVS     r0,#3
0002e8  ea402106          ORR      r1,r0,r6,LSL #8
0002ec  4628              MOV      r0,r5
0002ee  f7fffffe          BL       rt_hw_serial_isr
                  |L1.754|
;;;237    
;;;238        DMA_ClearFlag(uart->dma.rx_gl_flag);
0002f2  68e0              LDR      r0,[r4,#0xc]
0002f4  f7fffffe          BL       DMA_ClearFlag
;;;239    }
0002f8  e8bd81f0          POP      {r4-r8,pc}
;;;240    #endif /* RT_SERIAL_USING_DMA */ 
                          ENDP

                  uart_isr PROC
;;;246     */
;;;247    static void uart_isr(struct rt_serial_device *serial) {
0002fc  b570              PUSH     {r4-r6,lr}
0002fe  4605              MOV      r5,r0
;;;248        struct stm32_uart *uart = (struct stm32_uart *) serial->parent.user_data;
000300  6bec              LDR      r4,[r5,#0x3c]
;;;249    
;;;250        RT_ASSERT(uart != RT_NULL);
000302  b924              CBNZ     r4,|L1.782|
000304  22fa              MOVS     r2,#0xfa
000306  4946              LDR      r1,|L1.1056|
000308  a046              ADR      r0,|L1.1060|
00030a  f7fffffe          BL       rt_assert_handler
                  |L1.782|
;;;251    
;;;252        if(USART_GetITStatus(uart->uart_device, USART_IT_RXNE) != RESET)
00030e  f2405125          MOV      r1,#0x525
000312  6820              LDR      r0,[r4,#0]
000314  f7fffffe          BL       USART_GetITStatus
000318  b168              CBZ      r0,|L1.822|
;;;253        {
;;;254            if(USART_GetFlagStatus(uart->uart_device, USART_FLAG_PE) == RESET)
00031a  2101              MOVS     r1,#1
00031c  6820              LDR      r0,[r4,#0]
00031e  f7fffffe          BL       USART_GetFlagStatus
000322  b918              CBNZ     r0,|L1.812|
;;;255            {
;;;256                rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_IND);
000324  2101              MOVS     r1,#1
000326  4628              MOV      r0,r5
000328  f7fffffe          BL       rt_hw_serial_isr
                  |L1.812|
;;;257            }
;;;258            /* clear interrupt */
;;;259            USART_ClearITPendingBit(uart->uart_device, USART_IT_RXNE);
00032c  f2405125          MOV      r1,#0x525
000330  6820              LDR      r0,[r4,#0]
000332  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.822|
;;;260        }
;;;261    #ifdef RT_SERIAL_USING_DMA    
;;;262        if(USART_GetITStatus(uart->uart_device, USART_IT_IDLE) != RESET)
000336  f2404124          MOV      r1,#0x424
00033a  6820              LDR      r0,[r4,#0]
00033c  f7fffffe          BL       USART_GetITStatus
000340  b110              CBZ      r0,|L1.840|
;;;263        {
;;;264            dma_uart_rx_idle_isr(serial);
000342  4628              MOV      r0,r5
000344  f7fffffe          BL       dma_uart_rx_idle_isr
                  |L1.840|
;;;265        }
;;;266    #endif /* RT_SERIAL_USING_DMA */     
;;;267        if (USART_GetITStatus(uart->uart_device, USART_IT_TC) != RESET)
000348  f2406126          MOV      r1,#0x626
00034c  6820              LDR      r0,[r4,#0]
00034e  f7fffffe          BL       USART_GetITStatus
000352  b190              CBZ      r0,|L1.890|
;;;268        {
;;;269            /* clear interrupt */
;;;270            if(serial->parent.open_flag & RT_DEVICE_FLAG_INT_TX)
000354  8b28              LDRH     r0,[r5,#0x18]
000356  f4006080          AND      r0,r0,#0x400
00035a  b118              CBZ      r0,|L1.868|
;;;271            {
;;;272                rt_hw_serial_isr(serial, RT_SERIAL_EVENT_TX_DONE);
00035c  2102              MOVS     r1,#2
00035e  4628              MOV      r0,r5
000360  f7fffffe          BL       rt_hw_serial_isr
                  |L1.868|
;;;273            }
;;;274            USART_ITConfig(uart->uart_device, USART_IT_TC, DISABLE);
000364  2200              MOVS     r2,#0
000366  f2406126          MOV      r1,#0x626
00036a  6820              LDR      r0,[r4,#0]
00036c  f7fffffe          BL       USART_ITConfig
;;;275            USART_ClearITPendingBit(uart->uart_device, USART_IT_TC);
000370  f2406126          MOV      r1,#0x626
000374  6820              LDR      r0,[r4,#0]
000376  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.890|
;;;276        }
;;;277        if (USART_GetFlagStatus(uart->uart_device, USART_FLAG_ORE) == SET)
00037a  2108              MOVS     r1,#8
00037c  6820              LDR      r0,[r4,#0]
00037e  f7fffffe          BL       USART_GetFlagStatus
000382  2801              CMP      r0,#1
000384  d102              BNE      |L1.908|
;;;278        {
;;;279            USART_ReceiveData(uart->uart_device);
000386  6820              LDR      r0,[r4,#0]
000388  f7fffffe          BL       USART_ReceiveData
                  |L1.908|
;;;280        }
;;;281    }
00038c  bd70              POP      {r4-r6,pc}
;;;282    
                          ENDP

                  USART1_IRQHandler PROC
;;;307    
;;;308    void USART1_IRQHandler(void)
00038e  b510              PUSH     {r4,lr}
;;;309    {
;;;310        /* enter interrupt */
;;;311        rt_interrupt_enter();
000390  f7fffffe          BL       rt_interrupt_enter
;;;312    
;;;313        uart_isr(&serial1);
000394  4827              LDR      r0,|L1.1076|
000396  f7fffffe          BL       uart_isr
;;;314    
;;;315        /* leave interrupt */
;;;316        rt_interrupt_leave();
00039a  f7fffffe          BL       rt_interrupt_leave
;;;317    }
00039e  bd10              POP      {r4,pc}
;;;318    
                          ENDP

                  DMA1_Channel5_IRQHandler PROC
;;;319    #ifdef RT_SERIAL_USING_DMA
;;;320    void DMA1_Channel5_IRQHandler(void) {
0003a0  b510              PUSH     {r4,lr}
;;;321        /* enter interrupt */
;;;322        rt_interrupt_enter();
0003a2  f7fffffe          BL       rt_interrupt_enter
;;;323    
;;;324        dma_rx_done_isr(&serial1);
0003a6  4823              LDR      r0,|L1.1076|
0003a8  f7fffffe          BL       dma_rx_done_isr
;;;325    
;;;326        /* leave interrupt */
;;;327        rt_interrupt_leave();
0003ac  f7fffffe          BL       rt_interrupt_leave
;;;328    }
0003b0  bd10              POP      {r4,pc}
;;;329    #endif /* RT_SERIAL_USING_DMA */   
                          ENDP

                  USART2_IRQHandler PROC
;;;349    
;;;350    void USART2_IRQHandler(void)
0003b2  b510              PUSH     {r4,lr}
;;;351    {
;;;352        /* enter interrupt */
;;;353        rt_interrupt_enter();
0003b4  f7fffffe          BL       rt_interrupt_enter
;;;354    
;;;355        uart_isr(&serial2);
0003b8  481f              LDR      r0,|L1.1080|
0003ba  f7fffffe          BL       uart_isr
;;;356    
;;;357        /* leave interrupt */
;;;358        rt_interrupt_leave();
0003be  f7fffffe          BL       rt_interrupt_leave
;;;359    }
0003c2  bd10              POP      {r4,pc}
;;;360    
                          ENDP

                  DMA1_Channel6_IRQHandler PROC
;;;361    #ifdef RT_SERIAL_USING_DMA    
;;;362    void DMA1_Channel6_IRQHandler(void) {
0003c4  b510              PUSH     {r4,lr}
;;;363        /* enter interrupt */
;;;364        rt_interrupt_enter();
0003c6  f7fffffe          BL       rt_interrupt_enter
;;;365    
;;;366        dma_rx_done_isr(&serial2);
0003ca  481b              LDR      r0,|L1.1080|
0003cc  f7fffffe          BL       dma_rx_done_isr
;;;367    
;;;368        /* leave interrupt */
;;;369        rt_interrupt_leave();
0003d0  f7fffffe          BL       rt_interrupt_leave
;;;370    }
0003d4  bd10              POP      {r4,pc}
;;;371    #endif /* RT_SERIAL_USING_DMA */  
                          ENDP

                  USART3_IRQHandler PROC
;;;391    
;;;392    void USART3_IRQHandler(void)
0003d6  b510              PUSH     {r4,lr}
;;;393    {
;;;394        /* enter interrupt */
;;;395        rt_interrupt_enter();
0003d8  f7fffffe          BL       rt_interrupt_enter
;;;396    
;;;397        uart_isr(&serial3);
0003dc  4817              LDR      r0,|L1.1084|
0003de  f7fffffe          BL       uart_isr
;;;398    
;;;399        /* leave interrupt */
;;;400        rt_interrupt_leave();
0003e2  f7fffffe          BL       rt_interrupt_leave
;;;401    }
0003e6  bd10              POP      {r4,pc}
                  |L1.1000|
                          DCD      __FUNCTION__
                  |L1.1004|
0003ec  73657269          DCB      "serial != RT_NULL",0
0003f0  616c2021
0003f4  3d205254
0003f8  5f4e554c
0003fc  4c00    
0003fe  00                DCB      0
0003ff  00                DCB      0
                  |L1.1024|
000400  63666720          DCB      "cfg != RT_NULL",0
000404  213d2052
000408  545f4e55
00040c  4c4c00  
00040f  00                DCB      0
                  |L1.1040|
                          DCD      |symbol_number.13|
                  |L1.1044|
                          DCD      0xe000e180
                  |L1.1048|
                          DCD      |symbol_number.14|
                  |L1.1052|
                          DCD      |symbol_number.15|
                  |L1.1056|
                          DCD      |symbol_number.16|
                  |L1.1060|
000424  75617274          DCB      "uart != RT_NULL",0
000428  20213d20
00042c  52545f4e
000430  554c4c00
                  |L1.1076|
                          DCD      serial1
                  |L1.1080|
                          DCD      serial2
                  |L1.1084|
                          DCD      serial3
                          ENDP

                  DMA1_Channel3_IRQHandler PROC
;;;403    #ifdef RT_SERIAL_USING_DMA  
;;;404    void DMA1_Channel3_IRQHandler(void) {
000440  b510              PUSH     {r4,lr}
;;;405        /* enter interrupt */
;;;406        rt_interrupt_enter();
000442  f7fffffe          BL       rt_interrupt_enter
;;;407    
;;;408        dma_rx_done_isr(&serial3);
000446  4860              LDR      r0,|L1.1480|
000448  f7fffffe          BL       dma_rx_done_isr
;;;409    
;;;410        /* leave interrupt */
;;;411        rt_interrupt_leave();
00044c  f7fffffe          BL       rt_interrupt_leave
;;;412    }
000450  bd10              POP      {r4,pc}
;;;413    #endif /* RT_SERIAL_USING_DMA */
                          ENDP

                  RCC_Configuration PROC
;;;458    
;;;459    static void RCC_Configuration(void)
000452  b510              PUSH     {r4,lr}
;;;460    {
;;;461    #if defined(RT_USING_UART1)
;;;462        /* Enable UART GPIO clocks */
;;;463        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000454  2101              MOVS     r1,#1
000456  2005              MOVS     r0,#5
000458  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;464        /* Enable UART clock */
;;;465        RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00045c  2101              MOVS     r1,#1
00045e  0388              LSLS     r0,r1,#14
000460  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;466    #endif /* RT_USING_UART1 */
;;;467    
;;;468    #if defined(RT_USING_UART2)
;;;469        /* Enable UART GPIO clocks */
;;;470        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000464  2101              MOVS     r1,#1
000466  2005              MOVS     r0,#5
000468  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;471        /* Enable UART clock */
;;;472        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00046c  2101              MOVS     r1,#1
00046e  0448              LSLS     r0,r1,#17
000470  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;473    #endif /* RT_USING_UART2 */
;;;474    
;;;475    #if defined(RT_USING_UART3)
;;;476        /* Enable UART GPIO clocks */
;;;477        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
000474  2101              MOVS     r1,#1
000476  2009              MOVS     r0,#9
000478  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;478        /* Enable UART clock */
;;;479        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
00047c  2101              MOVS     r1,#1
00047e  0488              LSLS     r0,r1,#18
000480  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;480    #endif /* RT_USING_UART3 */
;;;481    
;;;482    #if defined(RT_USING_UART4)
;;;483        /* Enable UART GPIO clocks */
;;;484        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;485        /* Enable UART clock */
;;;486        RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;487    #endif /* RT_USING_UART4 */
;;;488    }
000484  bd10              POP      {r4,pc}
;;;489    
                          ENDP

                  GPIO_Configuration PROC
;;;490    static void GPIO_Configuration(void)
000486  b508              PUSH     {r3,lr}
;;;491    {
;;;492        GPIO_InitTypeDef GPIO_InitStructure;
;;;493    
;;;494        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000488  2002              MOVS     r0,#2
00048a  f88d0002          STRB     r0,[sp,#2]
;;;495    
;;;496    #if defined(RT_USING_UART1)
;;;497        /* Configure USART Rx/tx PIN */
;;;498        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00048e  2004              MOVS     r0,#4
000490  f88d0003          STRB     r0,[sp,#3]
;;;499        GPIO_InitStructure.GPIO_Pin = UART1_GPIO_RX;
000494  0200              LSLS     r0,r0,#8
000496  f8ad0000          STRH     r0,[sp,#0]
;;;500        GPIO_Init(UART1_GPIO, &GPIO_InitStructure);
00049a  4669              MOV      r1,sp
00049c  484b              LDR      r0,|L1.1484|
00049e  f7fffffe          BL       GPIO_Init
;;;501    
;;;502        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0004a2  2018              MOVS     r0,#0x18
0004a4  f88d0003          STRB     r0,[sp,#3]
;;;503        GPIO_InitStructure.GPIO_Pin = UART1_GPIO_TX;
0004a8  f44f7000          MOV      r0,#0x200
0004ac  f8ad0000          STRH     r0,[sp,#0]
;;;504        GPIO_Init(UART1_GPIO, &GPIO_InitStructure);
0004b0  4669              MOV      r1,sp
0004b2  4846              LDR      r0,|L1.1484|
0004b4  f7fffffe          BL       GPIO_Init
;;;505    #endif /* RT_USING_UART1 */
;;;506    
;;;507    #if defined(RT_USING_UART2)
;;;508        /* Configure USART Rx/tx PIN */
;;;509        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0004b8  2004              MOVS     r0,#4
0004ba  f88d0003          STRB     r0,[sp,#3]
;;;510        GPIO_InitStructure.GPIO_Pin = UART2_GPIO_RX;
0004be  2008              MOVS     r0,#8
0004c0  f8ad0000          STRH     r0,[sp,#0]
;;;511        GPIO_Init(UART2_GPIO, &GPIO_InitStructure);
0004c4  4669              MOV      r1,sp
0004c6  4841              LDR      r0,|L1.1484|
0004c8  f7fffffe          BL       GPIO_Init
;;;512    
;;;513        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0004cc  2018              MOVS     r0,#0x18
0004ce  f88d0003          STRB     r0,[sp,#3]
;;;514        GPIO_InitStructure.GPIO_Pin = UART2_GPIO_TX;
0004d2  2004              MOVS     r0,#4
0004d4  f8ad0000          STRH     r0,[sp,#0]
;;;515        GPIO_Init(UART2_GPIO, &GPIO_InitStructure);
0004d8  4669              MOV      r1,sp
0004da  483c              LDR      r0,|L1.1484|
0004dc  f7fffffe          BL       GPIO_Init
;;;516    #endif /* RT_USING_UART2 */
;;;517    
;;;518    #if defined(RT_USING_UART3)
;;;519        /* Configure USART Rx/tx PIN */
;;;520        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0004e0  2004              MOVS     r0,#4
0004e2  f88d0003          STRB     r0,[sp,#3]
;;;521        GPIO_InitStructure.GPIO_Pin = UART3_GPIO_RX;
0004e6  0240              LSLS     r0,r0,#9
0004e8  f8ad0000          STRH     r0,[sp,#0]
;;;522        GPIO_Init(UART3_GPIO, &GPIO_InitStructure);
0004ec  4669              MOV      r1,sp
0004ee  4838              LDR      r0,|L1.1488|
0004f0  f7fffffe          BL       GPIO_Init
;;;523    
;;;524        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0004f4  2018              MOVS     r0,#0x18
0004f6  f88d0003          STRB     r0,[sp,#3]
;;;525        GPIO_InitStructure.GPIO_Pin = UART3_GPIO_TX;
0004fa  f44f6080          MOV      r0,#0x400
0004fe  f8ad0000          STRH     r0,[sp,#0]
;;;526        GPIO_Init(UART3_GPIO, &GPIO_InitStructure);
000502  4669              MOV      r1,sp
000504  4832              LDR      r0,|L1.1488|
000506  f7fffffe          BL       GPIO_Init
;;;527    #endif /* RT_USING_UART3 */
;;;528    
;;;529    #if defined(RT_USING_UART4)
;;;530        /* Configure USART Rx/tx PIN */
;;;531        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;532        GPIO_InitStructure.GPIO_Pin = UART4_GPIO_RX;
;;;533        GPIO_Init(UART4_GPIO, &GPIO_InitStructure);
;;;534    
;;;535        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;536        GPIO_InitStructure.GPIO_Pin = UART4_GPIO_TX;
;;;537        GPIO_Init(UART4_GPIO, &GPIO_InitStructure);
;;;538    #endif /* RT_USING_UART4 */
;;;539    }
00050a  bd08              POP      {r3,pc}
;;;540    
                          ENDP

                  NVIC_Configuration PROC
;;;541    static void NVIC_Configuration(struct stm32_uart* uart)
00050c  b538              PUSH     {r3-r5,lr}
;;;542    {
00050e  4604              MOV      r4,r0
;;;543        NVIC_InitTypeDef NVIC_InitStructure;
;;;544    
;;;545        /* Enable the USART1 Interrupt */
;;;546        NVIC_InitStructure.NVIC_IRQChannel = uart->irq;
000510  7920              LDRB     r0,[r4,#4]
000512  f88d0000          STRB     r0,[sp,#0]
;;;547        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000516  2000              MOVS     r0,#0
000518  f88d0001          STRB     r0,[sp,#1]
;;;548        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
00051c  2001              MOVS     r0,#1
00051e  f88d0002          STRB     r0,[sp,#2]
;;;549        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000522  f88d0003          STRB     r0,[sp,#3]
;;;550        NVIC_Init(&NVIC_InitStructure);
000526  4668              MOV      r0,sp
000528  f7fffffe          BL       NVIC_Init
;;;551    }
00052c  bd38              POP      {r3-r5,pc}
;;;552    
                          ENDP

                  rt_hw_usart_init PROC
;;;596    
;;;597    void rt_hw_usart_init(void)
00052e  b51c              PUSH     {r2-r4,lr}
;;;598    {
;;;599        struct stm32_uart* uart;
;;;600        struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;
000530  4928              LDR      r1,|L1.1492|
000532  c903              LDM      r1,{r0,r1}
000534  e9cd0100          STRD     r0,r1,[sp,#0]
;;;601    
;;;602        RCC_Configuration();
000538  f7fffffe          BL       RCC_Configuration
;;;603        GPIO_Configuration();
00053c  f7fffffe          BL       GPIO_Configuration
;;;604    
;;;605    #if defined(RT_USING_UART1)
;;;606        uart = &uart1;
000540  4c25              LDR      r4,|L1.1496|
;;;607        config.baud_rate = BAUD_RATE_115200;
000542  f44f30e1          MOV      r0,#0x1c200
000546  9000              STR      r0,[sp,#0]
;;;608    
;;;609        serial1.ops    = &stm32_uart_ops;
000548  4824              LDR      r0,|L1.1500|
00054a  4925              LDR      r1,|L1.1504|
00054c  6408              STR      r0,[r1,#0x40]  ; serial1
;;;610        serial1.config = config;
00054e  4608              MOV      r0,r1
000550  e9dd1200          LDRD     r1,r2,[sp,#0]
000554  e9c01211          STRD     r1,r2,[r0,#0x44]
;;;611    
;;;612        NVIC_Configuration(uart);
000558  4620              MOV      r0,r4
00055a  f7fffffe          BL       NVIC_Configuration
;;;613    
;;;614        /* register UART1 device */
;;;615        rt_hw_serial_register(&serial1, "uart1",
00055e  4623              MOV      r3,r4
000560  f2407203          MOV      r2,#0x703
000564  a11f              ADR      r1,|L1.1508|
000566  481e              LDR      r0,|L1.1504|
000568  f7fffffe          BL       rt_hw_serial_register
;;;616                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX |
;;;617                              RT_DEVICE_FLAG_INT_TX |   RT_DEVICE_FLAG_DMA_RX,
;;;618                              uart);
;;;619    #endif /* RT_USING_UART1 */
;;;620    
;;;621    #if defined(RT_USING_UART2)
;;;622        uart = &uart2;
00056c  4c1f              LDR      r4,|L1.1516|
;;;623    
;;;624        config.baud_rate = BAUD_RATE_115200;
00056e  f44f30e1          MOV      r0,#0x1c200
000572  9000              STR      r0,[sp,#0]
;;;625        serial2.ops    = &stm32_uart_ops;
000574  4819              LDR      r0,|L1.1500|
000576  491e              LDR      r1,|L1.1520|
000578  6408              STR      r0,[r1,#0x40]  ; serial2
;;;626        serial2.config = config;
00057a  4608              MOV      r0,r1
00057c  e9dd1200          LDRD     r1,r2,[sp,#0]
000580  e9c01211          STRD     r1,r2,[r0,#0x44]
;;;627    
;;;628        NVIC_Configuration(uart);
000584  4620              MOV      r0,r4
000586  f7fffffe          BL       NVIC_Configuration
;;;629    
;;;630        /* register UART2 device */
;;;631        rt_hw_serial_register(&serial2, "uart2",
00058a  4623              MOV      r3,r4
00058c  f2407203          MOV      r2,#0x703
000590  a118              ADR      r1,|L1.1524|
000592  4817              LDR      r0,|L1.1520|
000594  f7fffffe          BL       rt_hw_serial_register
;;;632                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX |
;;;633                              RT_DEVICE_FLAG_INT_TX |   RT_DEVICE_FLAG_DMA_RX,
;;;634                              uart);
;;;635    #endif /* RT_USING_UART2 */
;;;636    
;;;637    #if defined(RT_USING_UART3)
;;;638        uart = &uart3;
000598  4c18              LDR      r4,|L1.1532|
;;;639    
;;;640        config.baud_rate = BAUD_RATE_115200;
00059a  f44f30e1          MOV      r0,#0x1c200
00059e  9000              STR      r0,[sp,#0]
;;;641    
;;;642        serial3.ops    = &stm32_uart_ops;
0005a0  480e              LDR      r0,|L1.1500|
0005a2  4909              LDR      r1,|L1.1480|
0005a4  6408              STR      r0,[r1,#0x40]  ; serial3
;;;643        serial3.config = config;
0005a6  4608              MOV      r0,r1
0005a8  e9dd1200          LDRD     r1,r2,[sp,#0]
0005ac  e9c01211          STRD     r1,r2,[r0,#0x44]
;;;644    
;;;645        NVIC_Configuration(uart);
0005b0  4620              MOV      r0,r4
0005b2  f7fffffe          BL       NVIC_Configuration
;;;646    
;;;647        /* register UART3 device */
;;;648        rt_hw_serial_register(&serial3, "uart3",
0005b6  4623              MOV      r3,r4
0005b8  f2407203          MOV      r2,#0x703
0005bc  a110              ADR      r1,|L1.1536|
0005be  4802              LDR      r0,|L1.1480|
0005c0  f7fffffe          BL       rt_hw_serial_register
;;;649                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX |
;;;650                              RT_DEVICE_FLAG_INT_TX |   RT_DEVICE_FLAG_DMA_RX,
;;;651                              uart);
;;;652    #endif /* RT_USING_UART3 */
;;;653    
;;;654    #if defined(RT_USING_UART4)
;;;655        uart = &uart4;
;;;656    
;;;657        config.baud_rate = BAUD_RATE_115200;
;;;658    
;;;659        serial4.ops    = &stm32_uart_ops;
;;;660        serial4.config = config;
;;;661    
;;;662        NVIC_Configuration(uart);
;;;663    
;;;664        /* register UART4 device */
;;;665        rt_hw_serial_register(&serial4, "uart4",
;;;666                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX |
;;;667                              RT_DEVICE_FLAG_INT_TX |   RT_DEVICE_FLAG_DMA_RX,
;;;668                              uart);
;;;669    #endif /* RT_USING_UART4 */
;;;670    }
0005c4  bd1c              POP      {r2-r4,pc}
                          ENDP

0005c6  0000              DCW      0x0000
                  |L1.1480|
                          DCD      serial3
                  |L1.1484|
                          DCD      0x40010800
                  |L1.1488|
                          DCD      0x40010c00
                  |L1.1492|
                          DCD      ||.constdata||+0x54
                  |L1.1496|
                          DCD      uart1
                  |L1.1500|
                          DCD      stm32_uart_ops
                  |L1.1504|
                          DCD      serial1
                  |L1.1508|
0005e4  75617274          DCB      "uart1",0
0005e8  3100    
0005ea  00                DCB      0
0005eb  00                DCB      0
                  |L1.1516|
                          DCD      uart2
                  |L1.1520|
                          DCD      serial2
                  |L1.1524|
0005f4  75617274          DCB      "uart2",0
0005f8  3200    
0005fa  00                DCB      0
0005fb  00                DCB      0
                  |L1.1532|
                          DCD      uart3
                  |L1.1536|
000600  75617274          DCB      "uart3",0
000604  3300    
000606  00                DCB      0
000607  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  serial1
                          %        84
                  serial2
                          %        84
                  serial3
                          %        84

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  stm32_uart_ops
                          DCD      stm32_configure
                          DCD      stm32_control
                          DCD      stm32_putc
                          DCD      stm32_getc
                          DCD      0x00000000
                  __FUNCTION__
000014  73746d33          DCB      0x73,0x74,0x6d,0x33
000018  325f636f          DCB      0x32,0x5f,0x63,0x6f
00001c  6e666967          DCB      0x6e,0x66,0x69,0x67
000020  75726500          DCB      0x75,0x72,0x65,0x00
                  |symbol_number.13|
000024  73746d33          DCB      0x73,0x74,0x6d,0x33
000028  325f636f          DCB      0x32,0x5f,0x63,0x6f
00002c  6e74726f          DCB      0x6e,0x74,0x72,0x6f
000030  6c00              DCB      0x6c,0x00
                  |symbol_number.14|
000032  7374              DCB      0x73,0x74
000034  6d33325f          DCB      0x6d,0x33,0x32,0x5f
000038  70757463          DCB      0x70,0x75,0x74,0x63
00003c  00                DCB      0x00
                  |symbol_number.15|
00003d  73746d            DCB      0x73,0x74,0x6d
000040  33325f67          DCB      0x33,0x32,0x5f,0x67
000044  65746300          DCB      0x65,0x74,0x63,0x00
                  |symbol_number.16|
000048  75617274          DCB      0x75,0x61,0x72,0x74
00004c  5f697372          DCB      0x5f,0x69,0x73,0x72
000050  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0001c200
000058  08000100          DCB      0x08,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  uart1
                          DCD      0x40013800
000004  25000000          DCB      0x25,0x00,0x00,0x00
                          DCD      0x40020058
                          DCD      0x00010000
000010  0f000000          DCB      0x0f,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                  uart2
                          DCD      0x40004400
000020  26000000          DCB      0x26,0x00,0x00,0x00
                          DCD      0x4002006c
                          DCD      0x00100000
00002c  10000000          DCB      0x10,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                  uart3
                          DCD      0x40004800
00003c  27000000          DCB      0x27,0x00,0x00,0x00
                          DCD      0x40020030
                          DCD      0x00000100
000048  0d000000          DCB      0x0d,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "drivers\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_uart1____REV16|
#line 129 "..\\..\\components\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_usart_c_uart1____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_uart1____REVSH|
#line 144
|__asm___7_usart_c_uart1____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
